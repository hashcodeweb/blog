(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{458:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-17-13.5b887329.png"},459:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-18-14.20231f70.png"},460:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-20-05.3bad3756.png"},461:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-24-27.dbfd7ef2.png"},462:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-25-24.f9a9173f.png"},463:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-29-11.1f973915.png"},464:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-29-40.1eb9f4bd.png"},465:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-30-33.28721b13.png"},466:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-40-46.43dc8a3d.png"},467:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-41-52.cbdbdd96.png"},468:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-42-45.b07241a7.png"},469:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-53-14.4eaf4209.png"},470:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-15-57-33.f552c943.png"},471:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-06-14.624ea78d.png"},472:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-13-11.5005cafb.png"},473:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-37-48.e17a3f78.png"},474:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-38-07.09ba79a2.png"},475:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-41-31.c2b5fe79.png"},476:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-44-14.0dde7859.png"},477:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-51-29.19c2c2de.png"},478:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-52-37.76519a79.png"},479:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-54-42.5cf68c71.png"},480:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-55-38.75e12ead.png"},481:function(e,t,s){e.exports=s.p+"assets/img/2023-11-12-16-56-31.000da7ec.png"},512:function(e,t,s){"use strict";s.r(t);var a=s(2),i=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"git分支简单原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#git分支简单原理"}},[e._v("#")]),e._v(" Git分支简单原理")]),e._v(" "),t("p",[e._v("Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。")]),e._v(" "),t("p",[e._v("在进行提交操作时，Git 会保存一个提交对象（commit object）")]),e._v(" "),t("p",[e._v("该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。")]),e._v(" "),t("p",[e._v("暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git add README test.rb LICENSE\n$ git commit -m 'The initial commit of my project'\n")])])]),t("p",[e._v("当使用 "),t("code",[e._v("git commit")]),e._v(" 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。")]),e._v(" "),t("p",[e._v("现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(458),alt:""}})]),e._v(" "),t("p",[e._v("做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(459),alt:""}})]),e._v(" "),t("p",[e._v("Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 它会在每次的提交操作中自动向前移动。")]),e._v(" "),t("p",[e._v("提示：")]),e._v(" "),t("p",[e._v("Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(460),alt:""}})]),e._v(" "),t("h2",{attrs:{id:"分支创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分支创建"}},[e._v("#")]),e._v(" 分支创建")]),e._v(" "),t("p",[e._v("Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 "),t("code",[e._v("git branch")]),e._v(" 命令：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git branch testing\n")])])]),t("p",[e._v("这会在当前所在的提交对象上创建一个指针。\n"),t("img",{attrs:{src:s(461),alt:""}})]),e._v(" "),t("p",[e._v("那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 "),t("code",[e._v("HEAD")]),e._v(" 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 "),t("code",[e._v("HEAD")]),e._v(" 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 "),t("code",[e._v("HEAD")]),e._v(" 想象为当前分支的别名）。 在本例中，你仍然在 "),t("code",[e._v("master")]),e._v(" 分支上。 因为 "),t("code",[e._v("git branch")]),e._v(" 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(462),alt:""}})]),e._v(" "),t("p",[e._v("你可以简单地使用 "),t("code",[e._v("git log")]),e._v(" 命令查看各个分支当前所指的对象。 提供这一功能的参数是 "),t("code",[e._v("--decorate")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git log --oneline --decorate\nf30ab (HEAD, master, testing) add feature #32 - ability to add new\n34ac2 fixed bug #1328 - stack overflow under certain conditions\n98ca9 initial commit of my project\n")])])]),t("p",[e._v("正如你所见，当前 “"),t("code",[e._v("master")]),e._v("” 和 “"),t("code",[e._v("testing")]),e._v("” 分支均指向校验和以 "),t("code",[e._v("f30ab")]),e._v(" 开头的提交对象。")]),e._v(" "),t("h2",{attrs:{id:"分支切换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分支切换"}},[e._v("#")]),e._v(" 分支切换")]),e._v(" "),t("p",[e._v("要切换到一个已存在的分支，你需要使用 "),t("code",[e._v("git checkout")]),e._v(" 命令。 我们现在切换到新创建的 "),t("code",[e._v("testing")]),e._v(" 分支去：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git checkout testing\n")])])]),t("p",[e._v("这样 "),t("code",[e._v("HEAD")]),e._v(" 就指向 "),t("code",[e._v("testing")]),e._v(" 分支了。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(463),alt:""}})]),e._v(" "),t("p",[e._v("那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ vim test.rb\n$ git commit -a -m 'made a change'\n")])])]),t("p",[t("img",{attrs:{src:s(464),alt:""}})]),e._v(" "),t("p",[e._v("如图所示，你的 "),t("code",[e._v("testing")]),e._v(" 分支向前移动了，但是 "),t("code",[e._v("master")]),e._v(" 分支却没有，它仍然指向运行 "),t("code",[e._v("git checkout")]),e._v(" 时所指的对象。 这就有意思了，现在我们切换回 "),t("code",[e._v("master")]),e._v(" 分支看看：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git checkout master\n")])])]),t("p",[t("img",{attrs:{src:s(465),alt:""}})]),e._v(" "),t("p",[e._v("这条命令做了两件事。 一是使 "),t("code",[e._v("HEAD")]),e._v(" 指回 "),t("code",[e._v("master")]),e._v(" 分支，二是将工作目录恢复成 "),t("code",[e._v("master")]),e._v(" 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 "),t("code",[e._v("testing")]),e._v(" 分支所做的修改，以便于向另一个方向进行开发。")]),e._v(" "),t("p",[e._v("提示：分支切换会改变你工作目录中的文件\n在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。")]),e._v(" "),t("p",[e._v("我们不妨再稍微做些修改并提交：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ vim test.rb\n$ git commit -a -m 'made other changes'\n")])])]),t("p",[e._v("现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 "),t("code",[e._v("master")]),e._v(" 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有")]),e._v(" "),t("ul",[t("li",[e._v("branch")]),e._v(" "),t("li",[e._v("checkout")]),e._v(" "),t("li",[e._v("commit")])]),e._v(" "),t("p",[e._v("你可以简单地使用 "),t("code",[e._v("git log")]),e._v(" 命令查看分叉历史。 运行 "),t("code",[e._v("git log --oneline --decorate --graph --all")]),e._v(" ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git log --oneline --decorate --graph --all\n* c2b9e (HEAD, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature #32 - ability to add new formats to the\n* 34ac2 fixed bug #1328 - stack overflow under certain conditions\n* 98ca9 initial commit of my project\n")])])]),t("p",[e._v("由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？")]),e._v(" "),t("p",[e._v("这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。")]),e._v(" "),t("h1",{attrs:{id:"分支的新建与合并"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分支的新建与合并"}},[e._v("#")]),e._v(" 分支的新建与合并")]),e._v(" "),t("p",[e._v("让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("开发某个网站。")])]),e._v(" "),t("li",[t("p",[e._v("为实现某个新的需求，创建一个分支。")])]),e._v(" "),t("li",[t("p",[e._v("在这个分支上开展工作。")])])]),e._v(" "),t("p",[e._v("正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("切换到你的线上分支（production branch）。")])]),e._v(" "),t("li",[t("p",[e._v("为这个紧急任务新建一个分支，并在其中修复它。")])]),e._v(" "),t("li",[t("p",[e._v("在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。")])]),e._v(" "),t("li",[t("p",[e._v("切换回你最初工作的分支上，继续工作。")])])]),e._v(" "),t("h1",{attrs:{id:"新建分支"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新建分支"}},[e._v("#")]),e._v(" 新建分支")]),e._v(" "),t("p",[e._v("首先，我们假设你正在你的项目上工作，并且已经有一些提交。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(466),alt:""}})]),e._v(" "),t("p",[e._v("现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 "),t("code",[e._v("git checkout")]),e._v(" 命令：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('$ git checkout -b iss53\nSwitched to a new branch "iss53"\n')])])]),t("p",[e._v("它是下面两条命令的简写：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git branch iss53\n$ git checkout iss53\n")])])]),t("p",[t("img",{attrs:{src:s(467),alt:""}})]),e._v(" "),t("p",[e._v("你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，"),t("code",[e._v("iss53")]),e._v(" 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 HEAD 指针指向了 iss53 分支）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ vim index.html\n$ git commit -a -m 'added a new footer [issue 53]'\n")])])]),t("p",[t("img",{attrs:{src:s(468),alt:""}})]),e._v(" "),t("p",[e._v("现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 iss53 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 "),t("code",[e._v("master")]),e._v(" 分支。")]),e._v(" "),t("p",[e._v("但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 储藏与清理 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 master 分支了：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git checkout master\nSwitched to branch 'master'\n")])])]),t("p",[e._v("这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。")]),e._v(" "),t("p",[e._v("接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git checkout -b hotfix\nSwitched to a new branch 'hotfix'\n$ vim index.html\n$ git commit -a -m 'fixed the broken email address'\n[hotfix 1fb7853] fixed the broken email address\n 1 file changed, 2 insertions(+)\n")])])]),t("p",[t("img",{attrs:{src:s(469),alt:""}})]),e._v(" "),t("p",[e._v("你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 "),t("code",[e._v("master")]),e._v(" 分支来部署到线上。 你可以使用 "),t("code",[e._v("git merge")]),e._v(" 命令来达到上述目的：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git checkout master\n$ git merge hotfix\nUpdating f42c576..3a0874c\nFast-forward\n index.html | 2 ++\n 1 file changed, 2 insertions(+)\n")])])]),t("p",[e._v('在合并的时候，你应该注意到了"快进（fast-forward）"这个词。 由于当前 '),t("code",[e._v("master")]),e._v(" 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。")]),e._v(" "),t("p",[e._v("现在，最新的修改已经在 "),t("code",[e._v("master")]),e._v(" 分支所指向的提交快照中，你可以着手发布该修复了。")]),e._v(" "),t("p",[e._v("关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 "),t("code",[e._v("hotfix")]),e._v(" 分支，因为你已经不再需要它了 —— "),t("code",[e._v("master")]),e._v(" 分支已经指向了同一个位置。 你可以使用带 "),t("code",[e._v("-d")]),e._v(" 选项的 "),t("code",[e._v("git branch")]),e._v(" 命令来删除分支：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git branch -d hotfix\nDeleted branch hotfix (3a0874c).\n")])])]),t("p",[e._v("现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git checkout iss53\nSwitched to branch \"iss53\"\n$ vim index.html\n$ git commit -a -m 'finished the new footer [issue 53]'\n[iss53 ad82d7a] finished the new footer [issue 53]\n1 file changed, 1 insertion(+)\n")])])]),t("p",[t("img",{attrs:{src:s(470),alt:""}})]),e._v(" "),t("p",[e._v("你在 "),t("code",[e._v("hotfix")]),e._v(" 分支上所做的工作并没有包含到 "),t("code",[e._v("iss53")]),e._v(" 分支中。 如果你需要拉取 "),t("code",[e._v("hotfix")]),e._v(" 所做的修改，你可以使用 "),t("code",[e._v("git merge master")]),e._v(" 命令将 "),t("code",[e._v("master")]),e._v(" 分支合并入 "),t("code",[e._v("iss53")]),e._v(" 分支，或者你也可以等到 "),t("code",[e._v("iss53")]),e._v(" 分支完成其使命，再将其合并回 "),t("code",[e._v("master")]),e._v(" 分支。")]),e._v(" "),t("h2",{attrs:{id:"分支的合并"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分支的合并"}},[e._v("#")]),e._v(" 分支的合并")]),e._v(" "),t("p",[e._v("假设你已经修正了 #53 问题，并且打算将你的工作合并入 "),t("code",[e._v("master")]),e._v(" 分支。 为此，你需要合并 "),t("code",[e._v("iss53")]),e._v(" 分支到 "),t("code",[e._v("master")]),e._v(" 分支，这和之前你合并 "),t("code",[e._v("hotfix")]),e._v(" 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 "),t("code",[e._v("git merge")]),e._v(" 命令：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git checkout master\nSwitched to branch 'master'\n$ git merge iss53\nMerge made by the 'recursive' strategy.\nindex.html |    1 +\n1 file changed, 1 insertion(+)\n")])])]),t("p",[e._v("这和你之前合并 "),t("code",[e._v("hotfix")]),e._v(" 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，"),t("code",[e._v("master")]),e._v("分支所在提交并不是 "),t("code",[e._v("iss53")]),e._v(" 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(471),alt:""}})]),e._v(" "),t("p",[e._v("和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(472),alt:""}})]),e._v(" "),t("p",[e._v("需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。")]),e._v(" "),t("p",[e._v("既然你的修改已经合并进来了，你已经不再需要 iss53 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git branch -d iss53\n")])])]),t("h2",{attrs:{id:"遇到冲突时的分支合并"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遇到冲突时的分支合并"}},[e._v("#")]),e._v(" 遇到冲突时的分支合并")]),e._v(" "),t("p",[e._v("有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对"),t("strong",[e._v("同一个文件的同一个部分")]),e._v("进行了"),t("strong",[e._v("不同的修改")]),e._v("，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 的修改都涉及到"),t("strong",[e._v("同一个文件的同一处")]),e._v("，在合并它们的时候就会产生合并冲突：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git merge iss53\nAuto-merging index.html\nCONFLICT (content): Merge conflict in index.html\nAutomatic merge failed; fix conflicts and then commit the result.\n")])])]),t("p",[e._v("此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 "),t("code",[e._v("git status")]),e._v(" 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('$ git status\nOn branch master\nYou have unmerged paths.\n  (fix conflicts and run "git commit")\n\nUnmerged paths:\n  (use "git add <file>..." to mark resolution)\n\n    both modified:      index.html\n\nno changes added to commit (use "git add" and/or "git commit -a")\n')])])]),t("p",[e._v("任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<<<<<<< HEAD:index.html\n<div id="footer">contact : email.support@github.com</div>\n=======\n<div id="footer">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n')])])]),t("p",[e._v("这表示 "),t("code",[e._v("HEAD")]),e._v(" 所指示的版本（也就是你的 "),t("code",[e._v("master")]),e._v(" 分支所在的位置，因为你在运行 "),t("code",[e._v("merge")]),e._v(" 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 "),t("code",[e._v("iss53")]),e._v(" 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div id="footer">\nplease contact us at email.support@github.com\n</div>\n')])])]),t("p",[e._v("上述的冲突解决方案仅保留了其中一个分支的修改，并且 <<<<<<< , ======= , 和 >>>>>>> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 "),t("code",[e._v("git add")]),e._v(" 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。")]),e._v(" "),t("p",[e._v("如果你想使用图形化工具来解决冲突，你可以运行 "),t("code",[e._v("git mergetool")]),e._v("，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git mergetool\n\nThis message is displayed because 'merge.tool' is not configured.\nSee 'git mergetool --tool-help' or 'git help config' for more details.\n'git mergetool' will now attempt to use one of the following tools:\nopendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge\nMerging:\nindex.html\n\nNormal merge conflict for 'index.html':\n  {local}: modified file\n  {remote}: modified file\nHit return to start merge resolution tool (opendiff):\n")])])]),t("p",[e._v("如果你想使用除默认工具（在这里 Git 使用 opendiff 做为默认的合并工具，因为作者在 Mac 上运行该程序）外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。")]),e._v(" "),t("p",[e._v("等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 "),t("code",[e._v("git status")]),e._v(" 来确认所有的合并冲突都已被解决：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('$ git status\nOn branch master\nAll conflicts fixed but you are still merging.\n  (use "git commit" to conclude merge)\n\nChanges to be committed:\n\n    modified:   index.html\n')])])]),t("p",[e._v("如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 "),t("code",[e._v("git commit")]),e._v(" 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Merge branch 'iss53'\n\nConflicts:\n    index.html\n#\n# It looks like you may be committing a merge.\n# If this is not correct, please remove the file\n#\t.git/MERGE_HEAD\n# and try again.\n\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# On branch master\n# All conflicts fixed but you are still merging.\n#\n# Changes to be committed:\n#\tmodified:   index.html\n#\n")])])]),t("h1",{attrs:{id:"分支管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分支管理"}},[e._v("#")]),e._v(" 分支管理")]),e._v(" "),t("p",[e._v("现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。")]),e._v(" "),t("p",[t("code",[e._v("git branch")]),e._v(" 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git branch\n  iss53\n* master\n  testing\n")])])]),t("p",[e._v("注意 "),t("code",[e._v("master")]),e._v(" 分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 "),t("code",[e._v("HEAD")]),e._v(" 指针所指向的分支）。 这意味着如果在这时候提交，"),t("code",[e._v("master")]),e._v(" 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 Merge branch 'iss53'\n  testing 782fd34 add scott to the author list in the readmes\n")])])]),t("p",[t("code",[e._v("--merged")]),e._v(" 与 "),t("code",[e._v("--no-merged")]),e._v(" 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 "),t("code",[e._v("git branch --merged")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git branch --merged\n  iss53\n* master\n")])])]),t("p",[e._v("因为之前已经合并了 "),t("code",[e._v("iss53")]),e._v(" 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 * 号的分支通常可以使用 "),t("code",[e._v("git branch -d")]),e._v(" 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。")]),e._v(" "),t("p",[e._v("查看所有包含未合并工作的分支，可以运行 "),t("code",[e._v("git branch --no-merged：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git branch --no-merged\n  testing\n")])])]),t("p",[e._v("这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git branch -d testing\nerror: The branch 'testing' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D testing'.\n")])])]),t("p",[e._v("如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 -D 选项强制删除它。")]),e._v(" "),t("h1",{attrs:{id:"分支开发工作流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分支开发工作流"}},[e._v("#")]),e._v(" 分支开发工作流")]),e._v(" "),t("p",[e._v("已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？")]),e._v(" "),t("h2",{attrs:{id:"长期分支"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#长期分支"}},[e._v("#")]),e._v(" 长期分支")]),e._v(" "),t("p",[e._v("因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。")]),e._v(" "),t("p",[e._v("许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 "),t("code",[e._v("master")]),e._v(" 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 "),t("code",[e._v("develop")]),e._v(" 或者 "),t("code",[e._v("next")]),e._v(" 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 "),t("code",[e._v("master")]),e._v(" 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。")]),e._v(" "),t("p",[e._v("事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。\n"),t("img",{attrs:{src:s(473),alt:""}})]),e._v(" "),t("p",[e._v("通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(474),alt:""}})]),e._v(" "),t("p",[e._v("你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 "),t("code",[e._v("proposed")]),e._v("（建议） 或 "),t("code",[e._v("pu: proposed updates")]),e._v("（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 "),t("code",[e._v("next")]),e._v(" 或者 "),t("code",[e._v("master")]),e._v(" 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。")]),e._v(" "),t("h2",{attrs:{id:"特性分支"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性分支"}},[e._v("#")]),e._v(" 特性分支")]),e._v(" "),t("p",[e._v("特性分支对任何规模的项目都适用。 特性分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（VCS）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见")]),e._v(" "),t("p",[e._v("你已经在上一节中你创建的 "),t("code",[e._v("iss53")]),e._v(" 和 "),t("code",[e._v("hotfix")]),e._v(" 特性分支中看到过这种用法。 你在上一节用到的特性分支（"),t("code",[e._v("iss53")]),e._v(" 和 "),t("code",[e._v("hotfix")]),e._v(" 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。")]),e._v(" "),t("p",[e._v("考虑这样一个例子，你在 "),t("code",[e._v("master")]),e._v(" 分支上工作到 C1，这时为了解决一个问题而新建 "),t("code",[e._v("iss91")]),e._v(" 分支，在 "),t("code",[e._v("iss91")]),e._v(" 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 "),t("code",[e._v("iss91v2")]),e._v(" 分支试图用另一种方法解决那个问题，接着你回到 "),t("code",[e._v("master")]),e._v(" 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 "),t("code",[e._v("dumbidea")]),e._v(" 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：")]),e._v(" "),t("p",[t("img",{attrs:{src:s(475),alt:""}})]),e._v(" "),t("p",[e._v("现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案；另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\n"),t("img",{attrs:{src:s(476),alt:""}})]),e._v(" "),t("p",[e._v("我们将会在 分布式 Git 中向你揭示更多有关分支工作流的细节，因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。")]),e._v(" "),t("p",[e._v("请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。")]),e._v(" "),t("h2",{attrs:{id:"远程分支"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#远程分支"}},[e._v("#")]),e._v(" 远程分支")]),e._v(" "),t("p",[e._v("远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 "),t("code",[e._v("git ls-remote(remote)")]),e._v(" 来显式地获得远程引用的完整列表，或者通过 "),t("code",[e._v("git remote show (remote)")]),e._v(" 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。")]),e._v(" "),t("p",[e._v("远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。")]),e._v(" "),t("p",[e._v("它们以 "),t("code",[e._v("(remote)/(branch)")]),e._v(" 形式命名。 例如，如果你想要看你最后一次与远程仓库 "),t("code",[e._v("origin")]),e._v(" 通信时 "),t("code",[e._v("master")]),e._v(" 分支的状态，你可以查看 "),t("code",[e._v("origin/master")]),e._v(" 分支。 你与同事合作解决一个问题并且他们推送了一个 "),t("code",[e._v("iss53")]),e._v(" 分支，你可能有自己的本地 "),t("code",[e._v("iss53")]),e._v(" 分支；但是在服务器上的分支会指向 "),t("code",[e._v("origin/iss53")]),e._v(" 的提交。")]),e._v(" "),t("p",[e._v("这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 "),t("code",[e._v("git.ourcompany.com")]),e._v(" 的 Git 服务器。 如果你从这里克隆，Git 的 "),t("code",[e._v("clone")]),e._v(" 命令会为你自动将其命名为 "),t("code",[e._v("origin")]),e._v("，拉取它的所有数据，创建一个指向它的 "),t("code",[e._v("master")]),e._v(" 分支的指针，并且在本地将其命名为 "),t("code",[e._v("origin/master")]),e._v("。 Git 也会给你一个与 "),t("code",[e._v("origin")]),e._v(" 的 "),t("code",[e._v("master")]),e._v(" 分支在指向同一个地方的本地 "),t("code",[e._v("master")]),e._v(" 分支，这样你就有工作的基础。")]),e._v(" "),t("p",[e._v("提示：“origin” 并无特殊含义\n远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 "),t("code",[e._v("git init")]),e._v(" 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 "),t("code",[e._v("git clone")]),e._v(" 时默认的远程仓库名字。 如果你运行 "),t("code",[e._v("git clone -o booyah")]),e._v("，那么你默认的远程分支名字将会是 "),t("code",[e._v("booyah/master")]),e._v("。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(477),alt:""}})]),e._v(" "),t("p",[e._v("如果你在本地的 "),t("code",[e._v("master")]),e._v(" 分支做了一些工作，然而在同一时间，其他人推送提交到 "),t("code",[e._v("git.ourcompany.com")]),e._v(" 并更新了它的 "),t("code",[e._v("master")]),e._v(" 分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 "),t("code",[e._v("origin")]),e._v(" 服务器连接，你的 "),t("code",[e._v("origin/master")]),e._v(" 指针就不会移动。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(478),alt:""}})]),e._v(" "),t("p",[e._v("如果要同步你的工作，运行 "),t("code",[e._v("git fetch origin")]),e._v(" 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com），从中抓取本地没有的数据，并且更新本地数据库，移动 "),t("code",[e._v("origin/master")]),e._v(" 指针指向新的、更新后的位置。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(479),alt:""}})]),e._v(" "),t("p",[e._v("为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 "),t("code",[e._v("git.team1.ourcompany.com")]),e._v("。 你可以运行 "),t("code",[e._v("git remote add")]),e._v(" 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 "),t("code",[e._v("teamone")]),e._v("，将其作为整个 URL 的缩写。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(480),alt:""}})]),e._v(" "),t("p",[e._v("现在，可以运行 "),t("code",[e._v("git fetch teamone")]),e._v(" 来抓取远程仓库 "),t("code",[e._v("teamone")]),e._v(" 有而本地没有的数据。 因为那台服务器上现有的数据是 "),t("code",[e._v("origin")]),e._v(" 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 "),t("code",[e._v("teamone")]),e._v(" 的 "),t("code",[e._v("master")]),e._v(" 分支。")]),e._v(" "),t("p",[t("img",{attrs:{src:s(481),alt:""}})]),e._v(" "),t("h2",{attrs:{id:"推送"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#推送"}},[e._v("#")]),e._v(" 推送")]),e._v(" "),t("p",[e._v("当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。")]),e._v(" "),t("p",[e._v("如果希望和别人一起在名为 "),t("code",[e._v("serverfix")]),e._v(" 的分支上工作，你可以像推送第一个分支那样推送它。 运行 "),t("code",[e._v("git push (remote) (branch)")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git push origin serverfix\nCounting objects: 24, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (15/15), done.\nWriting objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.\nTotal 24 (delta 2), reused 0 (delta 0)\nTo https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n")])])]),t("p",[e._v("这里有些工作被简化了。 Git 自动将 "),t("code",[e._v("serverfix")]),e._v(" 分支名字展开为 "),t("code",[e._v("refs/heads/serverfix:refs/heads/serverfix")]),e._v("，那意味着，“推送本地的 "),t("code",[e._v("serverfix")]),e._v(" 分支来更新远程仓库上的 "),t("code",[e._v("serverfix")]),e._v(" 分支。” 我们将会详细学习 Git 内部原理 的 "),t("code",[e._v("refs/heads/")]),e._v(" 部分，但是现在可以先把它放在儿。 你也可以运行 "),t("code",[e._v("git push origin serverfix:serverfix")]),e._v("，它会做同样的事 - 相当于它说，“推送本地的 "),t("code",[e._v("serverfix")]),e._v(" 分支，将其作为远程仓库的 "),t("code",[e._v("serverfix")]),e._v(" 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 "),t("code",[e._v("serverfix")]),e._v("，可以运行 "),t("code",[e._v("git push origin serverfix:awesomebranch")]),e._v(" 来将本地的 "),t("code",[e._v("serverfix")]),e._v(" 分支推送到远程仓库上的 "),t("code",[e._v("awesomebranch")]),e._v(" 分支。")]),e._v(" "),t("p",[e._v("提示：如何避免每次输入密码")]),e._v(" "),t("p",[e._v("如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。")]),e._v(" "),t("p",[e._v("如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “"),t("code",[e._v("credential cache")]),e._v("”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 "),t("code",[e._v("git config --global credential.helper cache")]),e._v(" 来设置它。")]),e._v(" "),t("p",[e._v("想要了解更多关于不同验证缓存的可用选项，查看 凭证存储。")]),e._v(" "),t("p",[e._v("下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 "),t("code",[e._v("origin/serverfix")]),e._v("，指向服务器的 "),t("code",[e._v("serverfix")]),e._v(" 分支的引用：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ git fetch origin\nremote: Counting objects: 7, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 3 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n")])])])])}),[],!1,null,null,null);t.default=i.exports}}]);