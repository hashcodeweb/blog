(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{537:function(t,e,o){"use strict";o.r(e);var v=o(2),a=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"object对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object对象"}},[t._v("#")]),t._v(" Object对象")]),t._v(" "),e("p",[t._v("JavaScript 的所有其他对象都继承自"),e("code",[t._v("Object")]),t._v("对象，即那些对象都是"),e("code",[t._v("Object")]),t._v("的实例。")]),t._v(" "),e("p",[t._v("而Object本质上是一个函数")]),t._v(" "),e("p",[e("code",[t._v("Object")]),t._v("对象的原生方法分成两类："),e("code",[t._v("Object")]),t._v("本身的方法与"),e("code",[t._v("Object")]),t._v("的实例方法。")]),t._v(" "),e("h2",{attrs:{id:"object本身的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object本身的方法"}},[t._v("#")]),t._v(" Object本身的方法")]),t._v(" "),e("p",[t._v("所谓“本身的方法”就是直接定义在Object对象的方法。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Object.print = function (o) { console.log(o) };\n")])])]),e("p",[t._v("上面代码中，print方法就是直接定义在Object对象上。")]),t._v(" "),e("h2",{attrs:{id:"object的实例方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object的实例方法"}},[t._v("#")]),t._v(" Object的实例方法")]),t._v(" "),e("p",[t._v("所谓实例方法就是定义在"),e("code",[t._v("Object")]),t._v("原型对象"),e("code",[t._v("Object.prototype")]),t._v("上的方法。它可以被"),e("code",[t._v("Object")]),t._v("实例直接使用。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Object.prototype.print = function () {\n  console.log(this);\n};\n\nvar obj = new Object();\nobj.print() // Object\n")])])]),e("p",[t._v("上面代码中，"),e("code",[t._v("Object.prototype")]),t._v("定义了一个"),e("code",[t._v("print")]),t._v("方法，然后生成一个"),e("code",[t._v("Object")]),t._v("的实例"),e("code",[t._v("obj")]),t._v("。"),e("code",[t._v("obj")]),t._v("直接继承了"),e("code",[t._v("Object.prototype")]),t._v("的属性和方法，可以直接使用"),e("code",[t._v("obj.print")]),t._v("调用"),e("code",[t._v("print")]),t._v("方法。也就是说，"),e("code",[t._v("obj")]),t._v("对象的"),e("code",[t._v("print")]),t._v("方法实质上就是调用"),e("code",[t._v("Object.prototype.print")]),t._v("方法。")]),t._v(" "),e("p",[t._v("凡是定义在"),e("code",[t._v("Object.prototype")]),t._v("对象上面的属性和方法，将被所有实例对象共享就可以了,可以理解prototype是它们的父类")]),t._v(" "),e("h2",{attrs:{id:"object-作为函数的用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-作为函数的用法"}},[t._v("#")]),t._v(" Object 作为函数的用法")]),t._v(" "),e("p",[t._v("Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。"),e("strong",[t._v("这个方法常用于保证某个值一定是对象")]),t._v("。")]),t._v(" "),e("p",[t._v("如果参数为空（或者为undefined和null），Object()返回一个空对象。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = Object();\n// 等同于\nvar obj = Object(undefined);\nvar obj = Object(null);\n\nobj instanceof Object // true\n")])])]),e("p",[t._v("上面代码的含义，是将"),e("code",[t._v("undefined")]),t._v("和"),e("code",[t._v("null")]),t._v("转为对象，结果得到了一个空对象"),e("code",[t._v("obj")]),t._v("。")]),t._v(" "),e("p",[e("code",[t._v("instanceof")]),t._v("运算符用来验证，一个对象是否为指定的构造函数的实例。"),e("code",[t._v("obj instanceof Object")]),t._v("返回"),e("code",[t._v("true")]),t._v("，就表示"),e("code",[t._v("obj")]),t._v("对象是"),e("code",[t._v("Object")]),t._v("的实例。")]),t._v(" "),e("p",[t._v("如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = Object(1);\nobj instanceof Object // true\nobj instanceof Number // true\n\nvar obj = Object('foo');\nobj instanceof Object // true\nobj instanceof String // true\n\nvar obj = Object(true);\nobj instanceof Object // true\nobj instanceof Boolean // true\n")])])]),e("p",[t._v("上面代码中，"),e("code",[t._v("Object")]),t._v("函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象。")]),t._v(" "),e("p",[t._v("如果"),e("code",[t._v("Object")]),t._v("方法的参数是一个对象，它总是返回该对象，即不用转换。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var arr = [];\nvar obj = Object(arr); // 返回原数组\nobj === arr // true\n\nvar value = {};\nvar obj = Object(value) // 返回原对象\nobj === value // true\n\nvar fn = function () {};\nvar obj = Object(fn); // 返回原函数\nobj === fn // true\n")])])]),e("p",[t._v("利用这一点，可以写一个判断变量是否为对象的函数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function isObject(value) {\n  return value === Object(value);\n}\n\nisObject([]) // true\nisObject(true) // false\n")])])]),e("h2",{attrs:{id:"object-构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-构造函数"}},[t._v("#")]),t._v(" Object 构造函数")]),t._v(" "),e("p",[e("code",[t._v("Object")]),t._v("不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用"),e("code",[t._v("new")]),t._v("命令。")]),t._v(" "),e("p",[e("code",[t._v("Object")]),t._v("构造函数的首要用途，是直接通过它来生成新对象。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = new Object();\n")])])]),e("blockquote",[e("p",[t._v("注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = {}是等价的。或者说，后者只是前者的一种简便写法。")])]),t._v(" "),e("p",[e("code",[t._v("Object")]),t._v("构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var o1 = {a: 1};\nvar o2 = new Object(o1);\no1 === o2 // true\n\nvar obj = new Object(123);\nobj instanceof Number // true\n")])])]),e("p",[t._v("虽然用法相似，但是"),e("code",[t._v("Object(value)")]),t._v("与"),e("code",[t._v("new Object(value)")]),t._v("两者的语义是不同的，"),e("code",[t._v("Object(value)")]),t._v("表示将"),e("code",[t._v("value")]),t._v("转成一个对象，"),e("code",[t._v("new Object(value)")]),t._v("则表示新生成一个对象，它的值是"),e("code",[t._v("value")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"object-的静态方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-的静态方法"}},[t._v("#")]),t._v(" Object 的静态方法")]),t._v(" "),e("p",[t._v("所谓“静态方法”，是指部署在Object对象自身的方法。")]),t._v(" "),e("h3",{attrs:{id:"object-keys-object-getownpropertynames"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-keys-object-getownpropertynames"}},[t._v("#")]),t._v(" Object.keys()，Object.getOwnPropertyNames()")]),t._v(" "),e("p",[e("code",[t._v("Object.keys")]),t._v("方法和"),e("code",[t._v("Object.getOwnPropertyNames")]),t._v("方法都用来"),e("strong",[t._v("遍历对象")]),t._v("的属性。")]),t._v(" "),e("p",[e("code",[t._v("Object.keys")]),t._v("方法的参数是一个对象，返回一个"),e("strong",[t._v("数组")]),t._v("。该数组的成员都是该对象"),e("strong",[t._v("自身的（而不是继承的）所有属性名。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var obj = {\n  p1: 123,\n  p2: 456\n};\n\nObject.keys(obj) // ["p1", "p2"]\n')])])]),e("p",[e("code",[t._v("Object.getOwnPropertyNames")]),t._v("方法与"),e("code",[t._v("Object.keys")]),t._v("类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var obj = {\n  p1: 123,\n  p2: 456\n};\n\nObject.getOwnPropertyNames(obj) // ["p1", "p2"]\n')])])]),e("p",[e("strong",[t._v("区别：")])]),t._v(" "),e("p",[t._v("对于一般的对象来说，"),e("code",[t._v("Object.keys()")]),t._v("和"),e("code",[t._v("Object.getOwnPropertyNames()")]),t._v("返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。"),e("code",[t._v("Object.keys")]),t._v("方法只返回可枚举的属性"),e("code",[t._v("Object.getOwnPropertyNames")]),t._v("方法还返回不可枚举的属性名。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var a = [\'Hello\', \'World\'];\n\nObject.keys(a) // ["0", "1"]\nObject.getOwnPropertyNames(a) // ["0", "1", "length"]\n')])])]),e("p",[t._v("上面代码中，数组的"),e("code",[t._v("length")]),t._v("属性是不可枚举的属性，所以只出现在"),e("code",[t._v("Object.getOwnPropertyNames")]),t._v("方法的返回结果中。")]),t._v(" "),e("p",[t._v("由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = {\n  p1: 123,\n  p2: 456\n};\n\nObject.keys(obj).length // 2\nObject.getOwnPropertyNames(obj).length // 2\n")])])]),e("p",[t._v("一般情况下，几乎总是使用"),e("code",[t._v("Object.keys")]),t._v("方法，遍历对象的属性。")]),t._v(" "),e("h2",{attrs:{id:"其他方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他方法"}},[t._v("#")]),t._v(" 其他方法")]),t._v(" "),e("p",[t._v("除了上面提到的两个方法，Object还有不少其他静态方法，将在后文逐一详细介绍。")]),t._v(" "),e("p",[e("strong",[t._v("（1）对象属性模型的相关方法")])]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Object.getOwnPropertyDescriptor()")]),t._v("：获取某个属性的描述对象。")]),t._v(" "),e("li",[e("code",[t._v("Object.defineProperty()")]),t._v("：通过描述对象，定义某个属性。")]),t._v(" "),e("li",[e("code",[t._v("Object.defineProperties()")]),t._v("：通过描述对象，定义多个属性。")])]),t._v(" "),e("p",[e("strong",[t._v("（2）控制对象状态的方法")])]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Object.preventExtensions()")]),t._v("：防止对象扩展。")]),t._v(" "),e("li",[e("code",[t._v("Object.isExtensible()")]),t._v("：判断对象是否可扩展。")]),t._v(" "),e("li",[e("code",[t._v("Object.seal()")]),t._v("：禁止对象配置。")]),t._v(" "),e("li",[e("code",[t._v("Object.isSealed()")]),t._v("：判断一个对象是否可配置。")]),t._v(" "),e("li",[e("code",[t._v("Object.freeze()")]),t._v("：冻结一个对象。")]),t._v(" "),e("li",[e("code",[t._v("Object.isFrozen()")]),t._v("：判断一个对象是否被冻结。")])]),t._v(" "),e("p",[e("strong",[t._v("（3）原型链相关方法")])]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Object.create()")]),t._v("：该方法可以指定原型对象和属性，返回一个新的对象。")]),t._v(" "),e("li",[e("code",[t._v("Object.getPrototypeOf()")]),t._v("：获取对象的Prototype对象。")])]),t._v(" "),e("h2",{attrs:{id:"object-的实例方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-的实例方法"}},[t._v("#")]),t._v(" Object 的实例方法")]),t._v(" "),e("p",[t._v("除了静态方法，还有不少方法定义在"),e("code",[t._v("Object.prototype")]),t._v("对象。它们称为实例方法，所有"),e("code",[t._v("Object")]),t._v("的实例对象都继承了这些方法。")]),t._v(" "),e("p",[e("code",[t._v("Object")]),t._v("实例对象的方法，主要有以下六个")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Object.prototype.valueOf()")]),t._v("：返回当前对象对应的值。")]),t._v(" "),e("li",[e("code",[t._v("Object.prototype.toString()")]),t._v("：返回当前对象对应的字符串形式。")]),t._v(" "),e("li",[e("code",[t._v("Object.prototype.toLocaleString()")]),t._v("：返回当前对象对应的本地字符串形式。")]),t._v(" "),e("li",[e("code",[t._v("Object.prototype.hasOwnProperty()")]),t._v("：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。")]),t._v(" "),e("li",[e("code",[t._v("Object.prototype.isPrototypeOf()")]),t._v("：判断当前对象是否为另一个对象的原型。")]),t._v(" "),e("li",[e("code",[t._v("Object.prototype.propertyIsEnumerable()")]),t._v("：判断某个属性是否可枚举。")])]),t._v(" "),e("h3",{attrs:{id:"object-prototype-valueof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-valueof"}},[t._v("#")]),t._v(" Object.prototype.valueOf()")]),t._v(" "),e("p",[t._v("valueOf方法的作用是返回一个对象的“值”，默认情况下返回对象本身。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = new Object();\nobj.valueOf() === obj // true\n")])])]),e("p",[t._v("上面代码比较"),e("code",[t._v("obj.valueOf()")]),t._v("与"),e("code",[t._v("obj")]),t._v("本身，两者是一样的。")]),t._v(" "),e("p",[e("code",[t._v("valueOf")]),t._v("方法的"),e("strong",[t._v("主要用途")]),t._v("是，JavaScript 自动类型转换时会默认调用这个方法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var obj = new Object();\n1 + obj // "1[object Object]"\n')])])]),e("p",[t._v("上面代码将对象"),e("code",[t._v("obj")]),t._v("与数字1相加，这时 JavaScript 就会默认调用"),e("code",[t._v("valueOf()")]),t._v("方法，求出obj的值再与1相加。所以，如果自定义"),e("code",[t._v("valueOf")]),t._v("方法，就可以得到想要的结果。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = new Object();\nobj.valueOf = function () {\n  return 2;\n};\n\n1 + obj // 3\n")])])]),e("p",[t._v("上面代码自定义了"),e("code",[t._v("obj")]),t._v("对象的"),e("code",[t._v("valueOf")]),t._v("方法，于是1 + obj就得到了3。这种方法就相当于用自定义的"),e("code",[t._v("obj.valueOf")]),t._v("，覆盖"),e("code",[t._v("Object.prototype.valueOf")]),t._v("。")]),t._v(" "),e("h3",{attrs:{id:"object-prototype-tostring"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-tostring"}},[t._v("#")]),t._v(" Object.prototype.toString()")]),t._v(" "),e("p",[e("code",[t._v("toString")]),t._v("方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var o1 = new Object();\no1.toString() // "[object Object]"\n\nvar o2 = {a:1};\no2.toString() // "[object Object]"\n')])])]),e("p",[t._v("上面代码表示，对于一个对象调用"),e("code",[t._v("toString")]),t._v("方法，会返回字符串"),e("code",[t._v("[object Object]")]),t._v("，该字符串说明对象的类型。")]),t._v(" "),e("p",[t._v("字符串"),e("code",[t._v("[object Object]")]),t._v("本身没有太大的用处，但是通过自定义"),e("code",[t._v("toString")]),t._v("方法，可以让对象在自动类型转换时，得到想要的字符串形式。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = new Object();\n\nobj.toString = function () {\n  return 'hello';\n};\n\nobj + ' ' + 'world' // \"hello world\"\n")])])]),e("p",[t._v("上面代码表示，当对象用于字符串加法时，会自动调用"),e("code",[t._v("toString")]),t._v("方法。由于自定义了"),e("code",[t._v("toString")]),t._v("方法，所以返回字符串"),e("code",[t._v("hello world")]),t._v("。")]),t._v(" "),e("p",[t._v("数组、字符串、函数、Date 对象都分别部署了自定义的"),e("code",[t._v("toString")]),t._v("方法，覆盖了"),e("code",[t._v("Object.prototype.toString")]),t._v("方法。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('[1, 2, 3].toString() // "1,2,3"\n\n\'123\'.toString() // "123"\n\n(function () {\n  return 123;\n}).toString()\n// "function () {\n//   return 123;\n// }"\n\n(new Date()).toString()\n// "Tue May 10 2016 09:11:31 GMT+0800 (CST)"\n')])])]),e("p",[t._v("上面代码中，数组、字符串、函数、Date 对象调用"),e("code",[t._v("toString")]),t._v("方法，并不会返回"),e("code",[t._v("[object Object]")]),t._v("，因为它们都自定义了"),e("code",[t._v("toString")]),t._v("方法，覆盖原始方法。")]),t._v(" "),e("h3",{attrs:{id:"tostring-的应用-判断数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tostring-的应用-判断数据类型"}},[t._v("#")]),t._v(" toString() 的应用：判断数据类型")]),t._v(" "),e("p",[e("code",[t._v("Object.prototype.toString")]),t._v("方法返回对象的类型字符串，因此可以用来判断一个值的类型。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var obj = {};\nobj.toString() // "[object Object]"\n')])])]),e("p",[t._v("上面代码调用空对象的"),e("code",[t._v("toString")]),t._v("方法，结果返回一个字符串"),e("code",[t._v("object Object")]),t._v("，其中第二个"),e("code",[t._v("Object")]),t._v("表示该值的构造函数。这是一个十分有用的判断数据类型的方法。")]),t._v(" "),e("p",[t._v("由于实例对象可能会自定义"),e("code",[t._v("toString")]),t._v("方法，覆盖掉"),e("code",[t._v("Object.prototype.toString")]),t._v("方法，所以为了得到类型字符串，最好直接使用"),e("code",[t._v("Object.prototype.toString")]),t._v("方法。通过函数的"),e("code",[t._v("call")]),t._v("方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Object.prototype.toString.call(value)\n")])])]),e("p",[t._v("上面代码表示对value这个值调用"),e("code",[t._v("Object.prototype.toString")]),t._v("方法。")]),t._v(" "),e("p",[t._v("不同数据类型的"),e("code",[t._v("Object.prototype.toString")]),t._v("方法返回值如下。")]),t._v(" "),e("ul",[e("li",[t._v("数值：返回[object Number]。")]),t._v(" "),e("li",[t._v("字符串：返回[object String]。")]),t._v(" "),e("li",[t._v("布尔值：返回[object Boolean]。")]),t._v(" "),e("li",[t._v("undefined：返回[object Undefined]。")]),t._v(" "),e("li",[t._v("null：返回[object Null]。")]),t._v(" "),e("li",[t._v("数组：返回[object Array]。")]),t._v(" "),e("li",[t._v("arguments 对象：返回[object Arguments]。")]),t._v(" "),e("li",[t._v("函数：返回[object Function]。")]),t._v(" "),e("li",[t._v("Error 对象：返回[object Error]。")]),t._v(" "),e("li",[t._v("Date 对象：返回[object Date]。")]),t._v(" "),e("li",[t._v("RegExp 对象：返回[object RegExp]。")]),t._v(" "),e("li",[t._v("其他对象：返回[object Object]。")])]),t._v(" "),e("p",[t._v("这就是说，"),e("code",[t._v("Object.prototype.toString")]),t._v("可以看出一个值到底是什么类型。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('Object.prototype.toString.call(2) // "[object Number]"\nObject.prototype.toString.call(\'\') // "[object String]"\nObject.prototype.toString.call(true) // "[object Boolean]"\nObject.prototype.toString.call(undefined) // "[object Undefined]"\nObject.prototype.toString.call(null) // "[object Null]"\nObject.prototype.toString.call(Math) // "[object Math]"\nObject.prototype.toString.call({}) // "[object Object]"\nObject.prototype.toString.call([]) // "[object Array]"\n')])])]),e("p",[t._v("利用这个特性，可以写出一个比"),e("code",[t._v("typeof")]),t._v("运算符更准确的类型判断函数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var type = function (o){\n  var s = Object.prototype.toString.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n};\n\ntype({}); // "object"\ntype([]); // "array"\ntype(5); // "number"\ntype(null); // "null"\ntype(); // "undefined"\ntype(/abcd/); // "regex"\ntype(new Date()); // "date"\n')])])]),e("p",[t._v("在上面这个"),e("code",[t._v("type")]),t._v("函数的基础上，还可以加上专门判断某种类型数据的方法。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var type = function (o){\n  var s = Object.prototype.toString.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n};\n\n['Null',\n 'Undefined',\n 'Object',\n 'Array',\n 'String',\n 'Number',\n 'Boolean',\n 'Function',\n 'RegExp'\n].forEach(function (t) {\n  type['is' + t] = function (o) {\n    return type(o) === t.toLowerCase();\n  };\n});\n\ntype.isObject({}) // true\ntype.isNumber(NaN) // true\ntype.isRegExp(/abc/) // true\n")])])]),e("h3",{attrs:{id:"object-prototype-tolocalestring"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-tolocalestring"}},[t._v("#")]),t._v(" Object.prototype.toLocaleString()")]),t._v(" "),e("p",[e("code",[t._v("Object.prototype.toLocaleString")]),t._v("方法与"),e("code",[t._v("toString")]),t._v("的返回结果相同，也是返回一个值的字符串形式。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var obj = {};\nobj.toString(obj) // "[object Object]"\nobj.toLocaleString(obj) // "[object Object]"\n')])])]),e("p",[t._v("这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的"),e("code",[t._v("toLocaleString")]),t._v("，用来返回针对某些地域的特定的值。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var person = {\n  toString: function () {\n    return 'Henry Norman Bethune';\n  },\n  toLocaleString: function () {\n    return '白求恩';\n  }\n};\n\nperson.toString() // Henry Norman Bethune\nperson.toLocaleString() // 白求恩\n")])])]),e("p",[t._v("上面代码中，"),e("code",[t._v("toString()")]),t._v("方法返回对象的一般字符串形式，"),e("code",[t._v("toLocaleString()")]),t._v("方法返回本地的字符串形式。")]),t._v(" "),e("p",[t._v("目前，主要有三个对象自定义了"),e("code",[t._v("toLocaleString")]),t._v("方法。")]),t._v(" "),e("ul",[e("li",[t._v("Array.prototype.toLocaleString()")]),t._v(" "),e("li",[t._v("Number.prototype.toLocaleString()")]),t._v(" "),e("li",[t._v("Date.prototype.toLocaleString()")])]),t._v(" "),e("p",[t._v("举例来说，日期的实例对象的"),e("code",[t._v("toString")]),t._v("和"),e("code",[t._v("toLocaleString")]),t._v("返回值就不一样，而且"),e("code",[t._v("toLocaleString")]),t._v("的返回值跟用户设定的所在地域相关。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var date = new Date();\ndate.toString() // "Tue Jan 01 2018 12:01:33 GMT+0800 (CST)"\ndate.toLocaleString() // "1/01/2018, 12:01:33 PM"\n')])])]),e("h3",{attrs:{id:"object-prototype-hasownproperty"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-hasownproperty"}},[t._v("#")]),t._v(" Object.prototype.hasOwnProperty()")]),t._v(" "),e("p",[e("code",[t._v("Object.prototype.hasOwnProperty")]),t._v("方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = {\n  p: 123\n};\n\nobj.hasOwnProperty('p') // true\nobj.hasOwnProperty('toString') // false\n")])])]),e("p",[t._v("上面代码中，对象"),e("code",[t._v("obj")]),t._v("自身具有"),e("code",[t._v("p")]),t._v("属性，所以返回"),e("code",[t._v("true")]),t._v("。"),e("code",[t._v("toString")]),t._v("属性是继承的，所以返回"),e("code",[t._v("false")]),t._v("。")])])}),[],!1,null,null,null);e.default=a.exports}}]);