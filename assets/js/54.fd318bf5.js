(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{514:function(t,a,s){"use strict";s.r(a);var r=s(2),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"git是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git是什么"}},[t._v("#")]),t._v(" GIT是什么？")]),t._v(" "),a("p",[t._v("git 是分布式版本控制系统，工作的时候不需要联网。它是目前世界上最先进的分布式版本控制系统。")]),t._v(" "),a("h1",{attrs:{id:"什么是版本控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是版本控制"}},[t._v("#")]),t._v(" 什么是版本控制？")]),t._v(" "),a("p",[t._v("是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术")]),t._v(" "),a("ul",[a("li",[t._v("实现跨区域多人协同开发")]),t._v(" "),a("li",[t._v("追踪和记载一个或者多个文件的历史记录")]),t._v(" "),a("li",[t._v("组织和保护你的源代码和文档")]),t._v(" "),a("li",[t._v("统计工作量")]),t._v(" "),a("li",[t._v("并行开发、提升开发效率")]),t._v(" "),a("li",[t._v("追踪记录整个软件的开发过程")]),t._v(" "),a("li",[t._v("减轻开发人员的负担，节省时间，同时降低认为错误")])]),t._v(" "),a("p",[t._v("无论是工作还是学习，或者自己做笔记，都经历过这样一个阶段，我们迫切需要一个版本控制工具。")]),t._v(" "),a("p",[t._v("多人开发必须要使用版本控制，否则代价太大")]),t._v(" "),a("p",[t._v("GIT svn cvs vss tfs 都是版本控制")]),t._v(" "),a("h1",{attrs:{id:"版本控制分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本控制分类"}},[t._v("#")]),t._v(" 版本控制分类")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("本地版本控制")])]),t._v(" "),a("li",[a("p",[t._v("集中版本控制")])])]),t._v(" "),a("p",[t._v("所有的数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改")]),t._v(" "),a("p",[t._v("服务器一坏，那就坏了吧，刚好毕业了")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("分布式版本控制\n所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在联网时，push到相应的服务器或其他用户那里，由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用")])]),t._v(" "),a("h1",{attrs:{id:"git与svn最主要的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git与svn最主要的区别"}},[t._v("#")]),t._v(" git与svn最主要的区别")]),t._v(" "),a("p",[t._v("svn时集中式版本控制系统，集中式版本控制系统是必须联网才能工作，对网络宽带要求比较高。")]),t._v(" "),a("h1",{attrs:{id:"git的官网下载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git的官网下载"}},[t._v("#")]),t._v(" git的官网下载")]),t._v(" "),a("p",[t._v("https://git-scm.com/")]),t._v(" "),a("h1",{attrs:{id:"如何卸载git"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何卸载git"}},[t._v("#")]),t._v(" 如何卸载Git？")]),t._v(" "),a("ol",[a("li",[t._v("清除环境变量")]),t._v(" "),a("li",[t._v("开始-设置-程序-卸载")])]),t._v(" "),a("h1",{attrs:{id:"如何安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何安装"}},[t._v("#")]),t._v(" 如何安装？")]),t._v(" "),a("p",[t._v("打开下载好的安装包，无脑下一步")]),t._v(" "),a("h1",{attrs:{id:"git的命令有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git的命令有哪些"}},[t._v("#")]),t._v(" git的命令有哪些？")]),t._v(" "),a("p",[t._v("都是linux的命令")]),t._v(" "),a("h1",{attrs:{id:"git的配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git的配置"}},[t._v("#")]),t._v(" git的配置")]),t._v(" "),a("p",[t._v("用户名\n邮箱")]),t._v(" "),a("h1",{attrs:{id:"git的工作区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git的工作区域"}},[t._v("#")]),t._v(" git的工作区域")]),t._v(" "),a("p",[t._v("本地：工作目录（Working）、暂存区(Stage)、本地资源库(Repository)\n远程：git仓库(Remote)")]),t._v(" "),a("p",[t._v("Working-(git add files)-Stage-(git commit)-History-(git push)-Remote\nRemote-(git pull)-History-(git reset)-Stage-(git checkout)-Working")]),t._v(" "),a("h1",{attrs:{id:"git-的六个基础命令与工作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-的六个基础命令与工作流程"}},[t._v("#")]),t._v(" git 的六个基础命令与工作流程")]),t._v(" "),a("h2",{attrs:{id:"获取仓库的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取仓库的方法"}},[t._v("#")]),t._v(" 获取仓库的方法")]),t._v(" "),a("p",[t._v("git init（初始化）\nclone（克隆远程仓库）")]),t._v(" "),a("h2",{attrs:{id:"提交"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提交"}},[t._v("#")]),t._v(" 提交：")]),t._v(" "),a("p",[t._v("本地工作命令（add）到暂存区域\n暂存区域（commit）到本地仓库\n本地仓库（push）到远程仓库")]),t._v(" "),a("h2",{attrs:{id:"拉取项目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拉取项目"}},[t._v("#")]),t._v(" 拉取项目")]),t._v(" "),a("p",[t._v("远程仓库（clone）到本地仓库\n本地仓库（checkout）到工作目录\n远程仓库（pull）到工作目录")]),t._v(" "),a("h1",{attrs:{id:"git的文件状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git的文件状态"}},[t._v("#")]),t._v(" git的文件状态")]),t._v(" "),a("ol",[a("li",[t._v("untracked")]),t._v(" "),a("li",[t._v("unmodify")]),t._v(" "),a("li",[t._v("modified （已修改）")]),t._v(" "),a("li")]),t._v(" "),a("h1",{attrs:{id:"与远程仓库的交互"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与远程仓库的交互"}},[t._v("#")]),t._v(" 与远程仓库的交互")]),t._v(" "),a("h2",{attrs:{id:"账号密码-交互"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#账号密码-交互"}},[t._v("#")]),t._v(" 账号密码 交互")]),t._v(" "),a("p",[t._v("......")]),t._v(" "),a("h2",{attrs:{id:"免密码-ssh密钥-交互"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#免密码-ssh密钥-交互"}},[t._v("#")]),t._v(" 免密码（ssh密钥）交互")]),t._v(" "),a("p",[t._v("通过(ssh-keygen -t rsa)命令生成一段公钥\n在github上输入自己的公钥，即可绑定成功")]),t._v(" "),a("h1",{attrs:{id:"git的分支"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git的分支"}},[t._v("#")]),t._v(" Git的分支")]),t._v(" "),a("p",[t._v("默认 master主分支\n查看分支:git branch\n创建分支:git branch <分支名>\n切换分支:git checkout <分支名>\n创建+切换分支:git checkout -b <分支名>\n合并某分支到当前分支:git merge <分支名>\n删除分支:git branch -d <分支名>\n修改分支名称:git branch -m <原名称> <新名称>\n查看已合并和未合并的分支:git branch --merged | --no-merged\n查看远程分支:git branch -r\n查看所有分支:git branch -a\n推送本地分支到远程:git push origin <分支名>\n删除远程分支:git push origin --delete <分支名>\n拉取远程分支到本地:git checkout -b <分支名> origin/<分支名>")]),t._v(" "),a("h1",{attrs:{id:"颜群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#颜群"}},[t._v("#")]),t._v(" 颜群")]),t._v(" "),a("h1",{attrs:{id:"git是全量的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git是全量的"}},[t._v("#")]),t._v(" git是全量的")]),t._v(" "),a("p",[t._v("就是说，每一个版本都包含全部的文件，时刻保持数据的完整性")]),t._v(" "),a("h1",{attrs:{id:"git的文件状态-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git的文件状态-2"}},[t._v("#")]),t._v(" git的文件状态")]),t._v(" "),a("p",[t._v("工作区\n暂存区\n对象区")]),t._v(" "),a("h1",{attrs:{id:"设置用户名和邮箱"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设置用户名和邮箱"}},[t._v("#")]),t._v(" 设置用户名和邮箱")]),t._v(" "),a("p",[t._v("--global （给当前用户配置）\n--system （给计算机配置）\n--local (给当前项目配置)")]),t._v(" "),a("h1",{attrs:{id:"gitignore-配置需要忽略的文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gitignore-配置需要忽略的文件"}},[t._v("#")]),t._v(" gitignore 配置需要忽略的文件")]),t._v(" "),a("p",[t._v("通配符*\ndir/:忽略dir目录中的所有文件\ndir/"),a("em",[t._v(".txt\ndir/")]),t._v("/"),a("em",[t._v(".txt 能够忽略 dir/abc/a.txt  dir/xyz/a.txt\ndir/**/")]),t._v(".txt  任意级别目录")]),t._v(" "),a("h1",{attrs:{id:"分支"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支"}},[t._v("#")]),t._v(" 分支")]),t._v(" "),a("p",[t._v("当前分支不能删除自己分支，可以在master分支删除分支")]),t._v(" "),a("h1",{attrs:{id:"什么是分支合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是分支合并"}},[t._v("#")]),t._v(" 什么是分支合并")]),t._v(" "),a("p",[t._v("它指的是将一个分支上的修改合并到另一个分支的操作。例如：\nmaster分支有a文件\ndeve分支基于master,有a文件和新增的b文件\n那么当在master分支上合并deve分支时:\nmaster分支现在会同时包含a文件和b文件\n原因是在合并时,Git会把deve分支上所有有差异的提交都合并到master分支")]),t._v(" "),a("h1",{attrs:{id:"解决分支合并的冲突方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决分支合并的冲突方式"}},[t._v("#")]),t._v(" 解决分支合并的冲突方式")]),t._v(" "),a("p",[t._v("编辑文件a,直接查看两边的修改,决定最终想要的内容\n删除特殊标记,完成文件编辑\n添加修改后的a文件,然后提交\n完成分支合并\n合并有冲突时,我们需要手动决定保留每个文件中哪些修改,这就完成了分支的合并")]),t._v(" "),a("h1",{attrs:{id:"什么是fast-forward"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是fast-forward"}},[t._v("#")]),t._v(" 什么是fast forward？")]),t._v(" "),a("p",[t._v("就是在分支合并（merge）时，master的commit会指向合并分支的最新commit\n在merge时，默认使用的时fast，也可以禁止 （git merge --no-ff）\n禁止fast可以保存分支合并的信息")]),t._v(" "),a("h1",{attrs:{id:"合并冲突怎么办"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合并冲突怎么办"}},[t._v("#")]),t._v(" 合并冲突怎么办？")]),t._v(" "),a("p",[t._v("两个分支修改同一文件同一行\n解决冲突还是git add commit -m （不是提交到版本库，而是告知冲突已经解决）")]),t._v(" "),a("h1",{attrs:{id:"分支合并的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支合并的分类"}},[t._v("#")]),t._v(" 分支合并的分类")]),t._v(" "),a("h2",{attrs:{id:"一种是没有冲突的合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一种是没有冲突的合并"}},[t._v("#")]),t._v(" 一种是没有冲突的合并")]),t._v(" "),a("p",[t._v("默认情况下，git使用的是fast\n当前分支合并到master分支，master分支的commit指针会指向当前分支最新的commit")]),t._v(" "),a("p",[t._v("也有第二种（git merge --no-ff）\n也就是禁止合并到同一个commit，这种方式会将master分支和当前分支合并到一起，并重新commit一次。")]),t._v(" "),a("h2",{attrs:{id:"一种是有冲突的合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一种是有冲突的合并"}},[t._v("#")]),t._v(" 一种是有冲突的合并")]),t._v(" "),a("p",[t._v("有冲突的合并需要手动接触冲突")]),t._v(" "),a("h1",{attrs:{id:"版本穿梭"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本穿梭"}},[t._v("#")]),t._v(" 版本穿梭")]),t._v(" "),a("p",[t._v("commmit其实是一个对象链，也可以说是一个引用，每一次commit都对生成一个commit对象，master指针指向最新一次commit的commit的对象")]),t._v(" "),a("h1",{attrs:{id:"什么是版本回退"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是版本回退"}},[t._v("#")]),t._v(" 什么是版本回退？")]),t._v(" "),a("p",[t._v("就是根据commit的对象链，将master主分支指向你想要回退到第几次的commit对象\n命令是：\n回退到n次： git reset --hard HEAD~n(n是数字)\n回到指定sha1值： git reset --hard sha1的前几位")]),t._v(" "),a("h1",{attrs:{id:"回退到commit后-还可以后悔吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回退到commit后-还可以后悔吗"}},[t._v("#")]),t._v(" 回退到commit后，还可以后悔吗？")]),t._v(" "),a("p",[t._v("可以通过git refog 查看记录，记录所有操作。")]),t._v(" "),a("h1",{attrs:{id:"checkout-的放弃与游离操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checkout-的放弃与游离操作"}},[t._v("#")]),t._v(" checkout 的放弃与游离操作")]),t._v(" "),a("p",[t._v("可以查看以前commit的版本，但是不要修改，因为修改后必须提交")]),t._v(" "),a("h2",{attrs:{id:"版本穿梭-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本穿梭-2"}},[t._v("#")]),t._v(" 版本穿梭")]),t._v(" "),a("ol",[a("li",[t._v("修改后，必须提交")]),t._v(" "),a("li",[t._v("创建分支的好时机")])]),t._v(" "),a("p",[t._v("如果修改了，影响不了后面的commit对象，\n这个时候可以创建一个新分支")]),t._v(" "),a("h1",{attrs:{id:"分支重命名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支重命名"}},[t._v("#")]),t._v(" 分支重命名")]),t._v(" "),a("p",[t._v("git branch -m master(原来的名字) master2(改成这个名字)")]),t._v(" "),a("h1",{attrs:{id:"保存现场"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保存现场"}},[t._v("#")]),t._v(" 保存现场")]),t._v(" "),a("p",[t._v("(规范)")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("在功能没有开发完成前，不要commit")])]),t._v(" "),a("li",[a("p",[t._v("在没有commit前，不能切换分支\n如果还没有将某一个功能开发完毕，就要切换分支：\n建议：")])]),t._v(" "),a("li",[a("p",[t._v("保存现场（临时保存，stash）\ngit stash")])]),t._v(" "),a("li",[a("p",[t._v("还原现场：git stash pop(将原来保存的删除，用于还原内容)\ngit stash apply(还原内容，不删除原保存的内容)\n说白了，就是删除掉原来保存的现场。。。有点像游戏的存档，你保存这个存档的时候，你每次玩都是从这个内容开始...")])]),t._v(" "),a("li",[a("p",[t._v("查看现场：git stash list")])])]),t._v(" "),a("h1",{attrs:{id:"tag标签"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tag标签"}},[t._v("#")]),t._v(" Tag标签")]),t._v(" "),a("p",[t._v('适用于整个项目， 和具体的分支没有关系\ngit tag  XXX\ngit tag -a xxx -m "asd"\n查看标签 git tag\n删除标签 git tag -d 标签名')]),t._v(" "),a("h1",{attrs:{id:"diff差异化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff差异化"}},[t._v("#")]),t._v(" diff差异化..")]),t._v(" "),a("p",[t._v("git diff 主要是用来比较的\n主要是区与区的比较")]),t._v(" "),a("h1",{attrs:{id:"以上基本就是git的本地仓库的大致内容了"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#以上基本就是git的本地仓库的大致内容了"}},[t._v("#")]),t._v(" 以上基本就是git的本地仓库的大致内容了")]),t._v(" "),a("h1",{attrs:{id:"github"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#github"}},[t._v("#")]),t._v(" github")]),t._v(" "),a("p",[t._v("push 本地-github\npull github-本地")])])}),[],!1,null,null,null);a.default=v.exports}}]);