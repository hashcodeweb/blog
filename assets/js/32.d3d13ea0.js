(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{453:function(t,a,e){t.exports=e.p+"assets/img/2023-11-11-20-25-18.962f1c2f.png"},454:function(t,a,e){t.exports=e.p+"assets/img/2023-11-11-20-25-43.32216dbc.png"},455:function(t,a,e){t.exports=e.p+"assets/img/2023-11-11-20-27-42.a42daf63.png"},456:function(t,a,e){t.exports=e.p+"assets/img/2023-11-11-21-13-41.04cefa13.png"},457:function(t,a,e){t.exports=e.p+"assets/img/2023-11-11-22-30-42.55d56abc.png"},511:function(t,a,e){"use strict";e.r(a);var s=e(2),i=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"什么是版本控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是版本控制"}},[t._v("#")]),t._v(" 什么是版本控制?")]),t._v(" "),a("p",[t._v("版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统")]),t._v(" "),a("p",[t._v("可以对任何类型的文件进行版本控制。")]),t._v(" "),a("h1",{attrs:{id:"本地版本控制系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本地版本控制系统"}},[t._v("#")]),t._v(" 本地版本控制系统")]),t._v(" "),a("p",[a("img",{attrs:{src:e(453),alt:""}})]),t._v(" "),a("h1",{attrs:{id:"集中化的版本控制系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集中化的版本控制系统"}},[t._v("#")]),t._v(" 集中化的版本控制系统")]),t._v(" "),a("p",[a("img",{attrs:{src:e(454),alt:""}})]),t._v(" "),a("h1",{attrs:{id:"分布式版本控制系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式版本控制系统"}},[t._v("#")]),t._v(" 分布式版本控制系统")]),t._v(" "),a("p",[a("img",{attrs:{src:e(455),alt:""}})]),t._v(" "),a("h1",{attrs:{id:"基础概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础概念"}},[t._v("#")]),t._v(" 基础概念")]),t._v(" "),a("h2",{attrs:{id:"什么是文件状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是文件状态"}},[t._v("#")]),t._v(" 什么是文件状态？")]),t._v(" "),a("ul",[a("li",[t._v("文件状态指文件系统中记录和跟踪文件的各种元数据信息,比如:")]),t._v(" "),a("li",[t._v("文件权限和属主 - 记录文件可以被哪些用户访问和修改。")]),t._v(" "),a("li",[t._v("文件类型 - 是否普通文件、目录、符号链接等。")]),t._v(" "),a("li",[t._v("文件大小 - 文件的实际占用空间大小。")]),t._v(" "),a("li",[t._v("时间戳 - 文件创建/修改/访问时间。")]),t._v(" "),a("li",[t._v("inode信息 - 在某些文件系统中用于跟踪文件的唯一id。")]),t._v(" "),a("li",[t._v("块列表 - 文件内容所占用的块位置。")]),t._v(" "),a("li",[t._v("扩展属性 - 一些文件系统支持扩展文件属性。")]),t._v(" "),a("li",[t._v("访问控制列表 - 记录哪些用户/组可以访问文件。")])]),t._v(" "),a("p",[t._v("等等...")]),t._v(" "),a("p",[t._v("文件状态和文件内容一起,完整地描述了一个文件在文件系统中的所有信息。")]),t._v(" "),a("h2",{attrs:{id:"文件状态和文件内容有什么关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件状态和文件内容有什么关系"}},[t._v("#")]),t._v(" 文件状态和文件内容有什么关系？")]),t._v(" "),a("p",[t._v("文件状态不直接包含文件内容本身,但会包含文件内容相关的一些元信息。")]),t._v(" "),a("p",[t._v("可以理解为文件状态包含了文件内容的指针")]),t._v(" "),a("h2",{attrs:{id:"什么是快照"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是快照"}},[t._v("#")]),t._v(" 什么是快照？")]),t._v(" "),a("p",[t._v("快照(Snapshot)是对系统在某个时间点的状态进行保存的一个副本或镜像。它可以捕捉到那个时间点的数据、配置和状态等信息。")]),t._v(" "),a("h2",{attrs:{id:"快照和文件状态有什么关联"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快照和文件状态有什么关联"}},[t._v("#")]),t._v(" 快照和文件状态有什么关联？")]),t._v(" "),a("p",[t._v("快照在创建时会将某个时刻文件状态一起保存下来,而不仅仅是文件数据本身。这使得快照可以用于恢复文件对象的完整状态。")]),t._v(" "),a("p",[t._v("所以文件状态是一个非常重要的概念,它记录了所有用于识别和管理一个文件元数据。与文件内容一起组成完整的文件对象信息。")]),t._v(" "),a("h2",{attrs:{id:"什么是增量备份"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是增量备份"}},[t._v("#")]),t._v(" 什么是增量备份？")]),t._v(" "),a("p",[t._v("增量备份(Incremental Backup)是一种数据备份策略,它只备份与上一次备份后发生变化的数据,以此来减少备份所需的存储空间和时间。")]),t._v(" "),a("p",[t._v("增量备份只备份新增或修改过的数据,对于未发生变化的数据则不再重复备份。与全量备份不同,全量备份会完整备份全部数据,包括未变化的数据。")]),t._v(" "),a("p",[t._v("增量备份的优点是可以显著减少备份时间和所需的存储空间。但数据恢复时需要将多个增量备份链结合,复杂度较高。因此通常会配合全量备份使用。")]),t._v(" "),a("h2",{attrs:{id:"快照与拷贝文件有什么不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快照与拷贝文件有什么不同"}},[t._v("#")]),t._v(" 快照与拷贝文件有什么不同？")]),t._v(" "),a("p",[t._v("从某种程度上可以这样理解。")]),t._v(" "),a("p",[t._v("快照就像对文件/系统在某个时间点状态的一个拷贝或副本。它将那个时刻的数据和状态都完整地保存下来。")]),t._v(" "),a("p",[t._v("但快照与简单的文件拷贝也有一些不同:")]),t._v(" "),a("p",[t._v("快照通常是系统或数据库自动根据预定策略创建的,而文件拷贝更多是人工操作。")]),t._v(" "),a("p",[t._v("快照会保存文件状态而不仅仅是文件数据,所以可以用来恢复到指定时间点的完整系统。")]),t._v(" "),a("p",[t._v("快照使用一定机制(如复制on write)来避免占用太多存储空间。")]),t._v(" "),a("p",[t._v("快照可以进行增量备份,只保存与上一快照版本的差异。")]),t._v(" "),a("p",[t._v("快照可以与连续数据保护技术结合,实现定期快照和实时日志追踪。")]),t._v(" "),a("p",[t._v("所以从本质上来说,快照确实是对文件/系统的一个副本或拷贝,但实现方式更为智能高效,可以只保存差异、恢复状态等,提供更强大的功能。")]),t._v(" "),a("h1",{attrs:{id:"git基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git基础"}},[t._v("#")]),t._v(" Git基础")]),t._v(" "),a("p",[t._v("Git 是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。")]),t._v(" "),a("h2",{attrs:{id:"近乎所有操作都是本地执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#近乎所有操作都是本地执行"}},[t._v("#")]),t._v(" 近乎所有操作都是本地执行")]),t._v(" "),a("p",[t._v("要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。 你能立即看到项目历史。 如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理")]),t._v(" "),a("h2",{attrs:{id:"git-保证完整性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-保证完整性"}},[t._v("#")]),t._v(" Git 保证完整性")]),t._v(" "),a("p",[t._v("Git 中所有数据在存储前都计算校验和，然后以校验和来引用。")]),t._v(" "),a("p",[t._v("这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。")]),t._v(" "),a("p",[t._v("这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分")]),t._v(" "),a("p",[t._v("Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）")]),t._v(" "),a("p",[t._v("Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。")]),t._v(" "),a("h2",{attrs:{id:"git-一般只添加数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-一般只添加数据"}},[t._v("#")]),t._v(" Git 一般只添加数据")]),t._v(" "),a("p",[t._v("你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。")]),t._v(" "),a("h2",{attrs:{id:"git-的三种状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-的三种状态"}},[t._v("#")]),t._v(" git 的三种状态")]),t._v(" "),a("ul",[a("li",[t._v("已修改（modified）")]),t._v(" "),a("li",[t._v("已暂存（staged）")]),t._v(" "),a("li",[t._v("已提交（committed）")])]),t._v(" "),a("p",[t._v("已修改表示修改了文件，但还没保存到数据库中。")]),t._v(" "),a("p",[t._v("已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。")]),t._v(" "),a("p",[t._v("已提交表示数据已经安全的保存在本地数据库中。")]),t._v(" "),a("p",[t._v("由此引入三个工作区域的概念\n"),a("img",{attrs:{src:e(456),alt:""}})]),t._v(" "),a("p",[t._v("Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。")]),t._v(" "),a("h2",{attrs:{id:"基本的-git-工作流程如下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本的-git-工作流程如下"}},[t._v("#")]),t._v(" 基本的 Git 工作流程如下：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("在工作目录中修改文件。")])]),t._v(" "),a("li",[a("p",[t._v("暂存文件，将文件的快照放入暂存区域。")])]),t._v(" "),a("li",[a("p",[t._v("提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。")])])]),t._v(" "),a("h1",{attrs:{id:"下载地址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下载地址"}},[t._v("#")]),t._v(" 下载地址")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("https://git-scm.com/downloads\n")])])]),a("p",[t._v("打开后一直点击下一步直到完成")]),t._v(" "),a("h1",{attrs:{id:"初始配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始配置"}},[t._v("#")]),t._v(" 初始配置")]),t._v(" "),a("p",[t._v("Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("/etc/gitconfig")]),t._v(" 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 "),a("code",[t._v("--system")]),t._v(" 选项的 "),a("code",[t._v("git config")]),t._v(" 时，它会从此文件读写配置变量。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("~/.gitconfig")]),t._v(" 或 "),a("code",[t._v("~/.config/git/config")]),t._v(" 文件：只针对当前用户。 可以传递 "),a("code",[t._v("--global")]),t._v(" 选项让 Git 读写此文件。")])]),t._v(" "),a("li",[a("p",[t._v("当前使用仓库的 Git 目录中的 "),a("code",[t._v("config")]),t._v(" 文件（就是 "),a("code",[t._v(".git/config")]),t._v("）：针对该仓库。")])])]),t._v(" "),a("p",[t._v("每一个级别覆盖上一级别的配置，所以 "),a("code",[t._v(".git/config")]),t._v(" 的配置变量会覆盖 "),a("code",[t._v("/etc/gitconfig")]),t._v(" 中的配置变量。")]),t._v(" "),a("h2",{attrs:{id:"用户信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用户信息"}},[t._v("#")]),t._v(" 用户信息")]),t._v(" "),a("p",[t._v("当安装完 Git 应该做的第一件事就是设置你的"),a("strong",[t._v("用户名称")]),t._v("与"),a("strong",[t._v("邮件地址")]),t._v("。 这样做很重要，因为每一个 Git 的"),a("strong",[t._v("提交")]),t._v("都会使用这些信息，并且它会写入到你的"),a("strong",[t._v("每一次")]),t._v("提交中，不可更改：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git config --global user.name "John Doe"\n$ git config --global user.email johndoe@example.com\n')])])]),a("p",[t._v("再次强调，如果使用了 "),a("code",[t._v("--global")]),t._v(" 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 "),a("code",[t._v("--global")]),t._v(" 选项的命令来配置")]),t._v(" "),a("h2",{attrs:{id:"文本编辑器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文本编辑器"}},[t._v("#")]),t._v(" 文本编辑器")]),t._v(" "),a("p",[t._v("Git 会使用操作系统默认的文本编辑器，通常是 Vim")]),t._v(" "),a("p",[t._v("你使用的是 Windows 系统，那么可能需要搜索如何在 Git 中配置你最常用的编辑器")]),t._v(" "),a("h2",{attrs:{id:"检查配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检查配置"}},[t._v("#")]),t._v(" 检查配置")]),t._v(" "),a("p",[t._v("如果想要检查你的配置，可以使用 "),a("code",[t._v("git config --list")]),t._v(" 命令来列出所有 Git 当时能找到的配置。")]),t._v(" "),a("h1",{attrs:{id:"git基础-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git基础-2"}},[t._v("#")]),t._v(" Git基础")]),t._v(" "),a("h2",{attrs:{id:"获取-git-仓库的两种方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取-git-仓库的两种方法"}},[t._v("#")]),t._v(" 获取 Git 仓库的两种方法")]),t._v(" "),a("p",[t._v("第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。")]),t._v(" "),a("h3",{attrs:{id:"方法一-本地新建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法一-本地新建"}},[t._v("#")]),t._v(" 方法一 本地新建")]),t._v(" "),a("p",[t._v("在本地新建一个文件，对文件进行初始化")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git init \n")])])]),a("p",[t._v("或者指定一个文件夹作为Git的仓库")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git init newrepo\n")])])]),a("p",[t._v("初始化后，在当前目录下会出现一个名为 "),a("code",[t._v(".git")]),t._v(" 的目录，所有 Git 需要的数据和资源都存放在这个目录中。")]),t._v(" "),a("p",[t._v("如果当前目录下有几个文件想要纳入版本控制，需要先用 "),a("code",[t._v("git add")]),t._v(" 命令告诉 Git 开始对这些文件进行跟踪，然后提交：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git add *.c\n$ git add README\n$ git commit -m 'initial project version'\n")])])]),a("h3",{attrs:{id:"方法二-从github上克隆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法二-从github上克隆"}},[t._v("#")]),t._v(" 方法二 从github上克隆")]),t._v(" "),a("p",[t._v("克隆仓库的命令格式为：")]),t._v(" "),a("p",[a("code",[t._v("git clone [url]")]),t._v("\n比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：")]),t._v(" "),a("p",[a("code",[t._v("$ git clone git://github.com/schacon/grit.git")]),t._v("\n执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。")]),t._v(" "),a("p",[t._v("如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：\n"),a("code",[t._v("$ git clone git://github.com/schacon/grit.git mygrit")])]),t._v(" "),a("h2",{attrs:{id:"记录每次更新到仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#记录每次更新到仓库"}},[t._v("#")]),t._v(" 记录每次更新到仓库")]),t._v(" "),a("p",[t._v("工作目录下的每一个文件都只有两种状态：")]),t._v(" "),a("ul",[a("li",[t._v("已跟踪")]),t._v(" "),a("li",[t._v("未跟踪")])]),t._v(" "),a("p",[t._v("已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。")]),t._v(" "),a("p",[t._v("编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(457),alt:""}})]),t._v(" "),a("h2",{attrs:{id:"检查当前文件状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检查当前文件状态"}},[t._v("#")]),t._v(" 检查当前文件状态")]),t._v(" "),a("p",[t._v("要查看哪些文件处于什么状态，可以用 "),a("code",[t._v("git status")]),t._v(" 命令。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git status\nOn branch master\nnothing to commit, working directory clean\n")])])]),a("p",[t._v("这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是 “master”,这是默认的分支名。")]),t._v(" "),a("p",[t._v("在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ echo \'My Project\' > README\n$ git status\nOn branch master\nUntracked files:\n  (use "git add <file>..." to include in what will be committed)\n\n    README\n\nnothing added to commit but untracked files present (use "git add" to track)\n')])])]),a("p",[t._v("在状态报告中可以看到新建的 README 文件出现在 Untracked files 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”， 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。")]),t._v(" "),a("h2",{attrs:{id:"跟踪新文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跟踪新文件"}},[t._v("#")]),t._v(" 跟踪新文件")]),t._v(" "),a("p",[t._v("使用命令  "),a("code",[t._v("git add")]),t._v(" 开始跟踪一个文件。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git add README\n")])])]),a("p",[t._v("此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git status\nOn branch master\nChanges to be committed:\n  (use "git reset HEAD <file>..." to unstage)\n\n    new file:   README\n')])])]),a("p",[t._v("只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 你可能会想起之前我们使用 git init 后就运行了 git add (files) 命令，开始跟踪当前目录下的文件。 git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。")]),t._v(" "),a("h2",{attrs:{id:"暂存已修改文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#暂存已修改文件"}},[t._v("#")]),t._v(" 暂存已修改文件")]),t._v(" "),a("p",[t._v("现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 "),a("code",[t._v("git status")]),t._v(" 命令，会看到下面内容：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git status\nOn branch master\nChanges to be committed:\n  (use "git reset HEAD <file>..." to unstage)\n\n    new file:   README\n\nChanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n')])])]),a("p",[t._v("文件 "),a("code",[t._v("CONTRIBUTING.md")]),t._v(" 出现在 "),a("code",[t._v("Changes not staged for commit")]),t._v(" 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 "),a("code",[t._v("git add")]),t._v(" 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 "),a("code",[t._v("git add")]),t._v(' 将"CONTRIBUTING.md"放到暂存区，然后再看看 '),a("code",[t._v("git status")]),t._v(" 的输出：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git add CONTRIBUTING.md\n$ git status\nOn branch master\nChanges to be committed:\n  (use "git reset HEAD <file>..." to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n')])])]),a("p",[t._v("现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 CONTRIBUTING.md 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 git status 看看：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ vim CONTRIBUTING.md\n$ git status\nOn branch master\nChanges to be committed:\n  (use "git reset HEAD <file>..." to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n\nChanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n')])])]),a("p",[t._v("怎么回事？ 现在 CONTRIBUTING.md 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 "),a("code",[t._v("git add")]),t._v(" 命令时的版本， 如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行 "),a("code",[t._v("git add")]),t._v(" 命令时的那个版本，而不是你运行 "),a("code",[t._v("git commit")]),t._v(" 时，在工作目录中的当前版本。 所以，运行了 "),a("code",[t._v("git add")]),t._v(" 之后又作了修订的文件，需要重新运行 "),a("code",[t._v("git add")]),t._v(" 把最新版本重新暂存起来：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git add CONTRIBUTING.md\n$ git status\nOn branch master\nChanges to be committed:\n  (use "git reset HEAD <file>..." to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n')])])]),a("h2",{attrs:{id:"忽略文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#忽略文件"}},[t._v("#")]),t._v(" 忽略文件")]),t._v(" "),a("p",[t._v("总会有些文件无需纳入 Git 的管理")]),t._v(" "),a("p",[t._v("可以创建一个名为 "),a("code",[t._v(".gitignore")]),t._v(" 的文件")]),t._v(" "),a("ul",[a("li",[t._v("通配符*")]),t._v(" "),a("li",[t._v("dir/:忽略dir目录中的所有文件")]),t._v(" "),a("li",[t._v("dir/*.txt")]),t._v(" "),a("li",[t._v("dir/"),a("em",[t._v("/")]),t._v(".txt 能够忽略 dir/abc/a.txt  dir/xyz/a.txt")]),t._v(" "),a("li",[t._v("dir/**/*.txt  任意级别目录")])]),t._v(" "),a("p",[t._v("文件 "),a("code",[t._v(".gitignore")]),t._v(" 的格式规范如下：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("所有空行或者以 ＃ 开头的行都会被 Git 忽略。")])]),t._v(" "),a("li",[a("p",[t._v("可以使用标准的 glob 模式匹配。")])]),t._v(" "),a("li",[a("p",[t._v("匹配模式可以以（/）开头防止递归。")])]),t._v(" "),a("li",[a("p",[t._v("匹配模式可以以（/）结尾指定目录。")])]),t._v(" "),a("li",[a("p",[t._v("要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。")])])]),t._v(" "),a("p",[t._v("所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号("),a("code",[t._v("*")]),t._v(")匹配零个或多个任意字符；"),a("code",[t._v("[abc]")]),t._v(" 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号(*) 表示匹配任意中间目录，比如"),a("code",[t._v("a/**/z")]),t._v(" 可以匹配 a/z, a/b/z 或 "),a("code",[t._v("a/b/c/z")]),t._v("等。")]),t._v(" "),a("h2",{attrs:{id:"查看已暂存和未暂存的修改-差异化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看已暂存和未暂存的修改-差异化"}},[t._v("#")]),t._v(" 查看已暂存和未暂存的修改-差异化")]),t._v(" "),a("p",[t._v("如果 "),a("code",[t._v("git status")]),t._v(" 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 "),a("code",[t._v("git diff")]),t._v(" 命令")]),t._v(" "),a("p",[t._v("你可能通常会用它来回答这两个问题：")]),t._v(" "),a("ol",[a("li",[t._v("当前做的哪些更新还没有暂存？")]),t._v(" "),a("li",[t._v("有哪些更新已经暂存起来准备好了下次提交？")])]),t._v(" "),a("p",[t._v("尽管 "),a("code",[t._v("git status")]),t._v(" 已经通过在相应栏下列出文件名的方式回答了这个问题\n"),a("code",[t._v("git diff")]),t._v(" 将通过文件补丁的格式显示具体哪些行发生了改变。")]),t._v(" "),a("p",[t._v("此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。")]),t._v(" "),a("p",[t._v("若要查看已暂存的将要添加到下次提交里的内容，可以用 "),a("code",[t._v("git diff --cached")]),t._v(" 命令。（Git 1.6.1 及更高版本还允许使用 "),a("code",[t._v("git diff --staged")]),t._v("，效果是相同的，但更好记些。）")]),t._v(" "),a("p",[t._v("请注意，"),a("code",[t._v("git diff")]),t._v(" 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 "),a("code",[t._v("git diff")]),t._v(" 后却什么也没有，就是这个原因。")]),t._v(" "),a("p",[t._v("如果你喜欢通过图形化的方式或其它格式输出方式的话，可以使用 git difftool 命令来用 Araxis ，emerge 或 vimdiff 等软件输出 diff 分析结果。 使用 git difftool --tool-help 命令来看你的系统支持哪些 Git Diff 插件。")]),t._v(" "),a("h2",{attrs:{id:"提交更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提交更新"}},[t._v("#")]),t._v(" 提交更新")]),t._v(" "),a("p",[t._v("现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 "),a("code",[t._v("git add")]),t._v(" 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 "),a("code",[t._v("git status")]),t._v(" 看下，是不是都已暂存起来了， 然后再运行提交命令")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git commit\n")])])]),a("p",[t._v("这种方式会启动文本编辑器以便输入本次提交的说明。")]),t._v(" "),a("p",[t._v("也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git commit -m "message"\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git commit -m "Story 182: Fix benchmarks for speed"\n[master 463dc4f] Story 182: Fix benchmarks for speed\n 2 files changed, 2 insertions(+)\n create mode 100644 README\n')])])]),a("p",[t._v("提交后它会告诉你，当前是在哪个分支（"),a("code",[t._v("master")]),t._v("）提交的，本次提交的完整 SHA-1 校验和是什么（"),a("code",[t._v("463dc4f")]),t._v("），以及在本次提交中，有多少文件修订过，多少行添加和删改过。")]),t._v(" "),a("p",[t._v("请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。")]),t._v(" "),a("h2",{attrs:{id:"跳过使用暂存区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跳过使用暂存区域"}},[t._v("#")]),t._v(" 跳过使用暂存区域")]),t._v(" "),a("p",[t._v("尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('git commit -a -m "message"\n')])])]),a("p",[t._v("例子：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git status\nOn branch master\nChanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n\nno changes added to commit (use "git add" and/or "git commit -a")\n$ git commit -a -m \'added new benchmarks\'\n[master 83e38c7] added new benchmarks\n 1 file changed, 5 insertions(+), 0 deletions(-)\n')])])]),a("p",[t._v("提交之前不再需要 git add 文件“CONTRIBUTING.md”了。")]),t._v(" "),a("h2",{attrs:{id:"移除文件的两种情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移除文件的两种情况"}},[t._v("#")]),t._v(" 移除文件的两种情况")]),t._v(" "),a("p",[t._v("当文件还在工作区域，没有添加到暂存区时：")]),t._v(" "),a("p",[t._v("要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。")]),t._v(" "),a("p",[t._v("如果只是简单地从工作目录中手工删除文件，运行 "),a("code",[t._v("git status")]),t._v(" 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ rm PROJECTS.md\n$ git status\nOn branch master\nYour branch is up-to-date with \'origin/master\'.\nChanges not staged for commit:\n  (use "git add/rm <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n        deleted:    PROJECTS.md\n\nno changes added to commit (use "git add" and/or "git commit -a")\n')])])]),a("p",[t._v("然后再运行 git rm 记录此次移除文件的操作：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git rm PROJECTS.md\nrm 'PROJECTS.md'\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    deleted:    PROJECTS.md\n")])])]),a("p",[t._v("下一次提交时，该文件就不再纳入版本管理了。")]),t._v(" "),a("p",[t._v("如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。")]),t._v(" "),a("h3",{attrs:{id:"第一种情况-从暂存区移除-并且从工作区也删除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一种情况-从暂存区移除-并且从工作区也删除"}},[t._v("#")]),t._v(" 第一种情况 从暂存区移除，并且从工作区也删除")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git rm  README.md\n")])])]),a("p",[t._v("可以用 "),a("code",[t._v("git rm")]),t._v(" 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。")]),t._v(" "),a("h3",{attrs:{id:"第二种情况-从暂存区移除-但是文件还呆在工作区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二种情况-从暂存区移除-但是文件还呆在工作区"}},[t._v("#")]),t._v(" 第二种情况 从暂存区移除，但是文件还呆在工作区")]),t._v(" "),a("p",[t._v("就是说让文件保留在磁盘，但是并不想让 Git 继续跟踪")]),t._v(" "),a("p",[t._v("当你忘记添加 "),a("code",[t._v(".gitignore")]),t._v(" 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 "),a("code",[t._v("--cached")]),t._v("选项：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git rm --cached README\n")])])]),a("p",[t._v("git rm 命令后面可以列出文件或者目录的名字,也可以正则表达式。")]),t._v(" "),a("h2",{attrs:{id:"移动文件或重命名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移动文件或重命名"}},[t._v("#")]),t._v(" 移动文件或重命名")]),t._v(" "),a("p",[t._v("如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么")]),t._v(" "),a("p",[t._v("要在 Git 中对文件改名，可以这么做：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git mv file_from file_to\n")])])]),a("p",[t._v("其实，运行 git mv 就相当于运行了下面三条命令：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# 在工作区改名\n$ mv README.md README\n# 从暂存区和工作区删除\n$ git rm README.md\n# 将工作区改了名字的文件重新添加进暂存区\n$ git add README\n")])])]),a("p",[t._v("如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。 两者唯一的区别是，mv 是一条命令而另一种方式需要三条命令，直接用 "),a("code",[t._v("git mv")]),t._v(" 轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。")]),t._v(" "),a("h2",{attrs:{id:"查看提交历史-查看日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看提交历史-查看日志"}},[t._v("#")]),t._v(" 查看提交历史(查看日志)")]),t._v(" "),a("p",[t._v("在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 "),a("code",[t._v("git log")]),t._v(" 命令。")]),t._v(" "),a("p",[t._v("默认不用任何参数的话，"),a("code",[t._v("git log")]),t._v(" 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 "),a("code",[t._v("SHA-1")]),t._v(" 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("-p")]),t._v(" 用来显示每次提交的内容差异")]),t._v(" "),a("li",[a("code",[t._v("-2")]),t._v(" 仅显示最近两次提交")]),t._v(" "),a("li",[a("code",[t._v("--stat")]),t._v("查看每次提交的简略的统计信息")]),t._v(" "),a("li",[a("code",[t._v("--pretty")]),t._v("可以指定使用不同于默认格式的方式展示提交历史.这个选项有一些内建的子选项供你使用。 比如用 "),a("code",[t._v("oneline")]),t._v(" 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 "),a("code",[t._v("short")]),t._v("，"),a("code",[t._v("full")]),t._v(" 和 "),a("code",[t._v("fuller")]),t._v(" 可以用")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git log --pretty=oneline\n")])])]),a("p",[a("code",[t._v("--stat")]),t._v(" 选项在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。")]),t._v(" "),a("p",[t._v("这个命令参数太多了...")]),t._v(" "),a("h2",{attrs:{id:"撤销操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#撤销操作"}},[t._v("#")]),t._v(" 撤销操作")]),t._v(" "),a("p",[t._v("有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令尝试重新提交：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git commit --amend\n")])])]),a("p",[t._v("这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。")]),t._v(" "),a("p",[t._v("文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。")]),t._v(" "),a("p",[t._v("例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git commit -m 'initial commit'\n$ git add forgotten_file\n$ git commit --amend\n")])])]),a("p",[t._v("最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。")]),t._v(" "),a("h2",{attrs:{id:"取消暂存的文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#取消暂存的文件"}},[t._v("#")]),t._v(" 取消暂存的文件")]),t._v(" "),a("p",[t._v("接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 "),a("code",[t._v("git add *")]),t._v(" 暂存了它们两个。 如何只取消暂存两个中的一个呢？ "),a("code",[t._v("git status")]),t._v(" 命令提示了你：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git add *\n$ git status\nOn branch master\nChanges to be committed:\n  (use "git reset HEAD <file>..." to unstage)\n\n    renamed:    README.md -> README\n    modified:   CONTRIBUTING.md\n')])])]),a("p",[t._v("在 “"),a("code",[t._v("Changes to be committed")]),t._v("” 文字正下方，提示使用 "),a("code",[t._v("git reset HEAD <file>...")]),t._v(" 来取消暂存。 所以，我们可以这样来取消暂存 "),a("code",[t._v("CONTRIBUTING.md")]),t._v(" 文件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git reset HEAD CONTRIBUTING.md\nUnstaged changes after reset:\nM\tCONTRIBUTING.md\n$ git status\nOn branch master\nChanges to be committed:\n  (use "git reset HEAD <file>..." to unstage)\n\n    renamed:    README.md -> README\n\nChanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n')])])]),a("p",[t._v("这个命令有点儿奇怪，但是起作用了。 "),a("code",[t._v("CONTRIBUTING.md")]),t._v(" 文件已经是修改未暂存的状态了。")]),t._v(" "),a("p",[t._v("这个命令了解到这里就可以了")]),t._v(" "),a("h2",{attrs:{id:"撤消对文件的修改"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#撤消对文件的修改"}},[t._v("#")]),t._v(" 撤消对文件的修改")]),t._v(" "),a("p",[t._v("如果你并不想保留对 "),a("code",[t._v("CONTRIBUTING.md")]),t._v(" 文件的修改怎么办？ 你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，"),a("code",[t._v("git status")]),t._v(" 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('Changes not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n')])])]),a("p",[t._v("它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('$ git checkout -- CONTRIBUTING.md\n$ git status\nOn branch master\nChanges to be committed:\n  (use "git reset HEAD <file>..." to unstage)\n\n    renamed:    README.md -> README\n')])])]),a("p",[t._v("可以看到那些修改已经被撤消了。")]),t._v(" "),a("p",[t._v("重要提示：你需要知道 "),a("code",[t._v("git checkout -- [file]")]),t._v(" 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。")]),t._v(" "),a("h1",{attrs:{id:"远程仓库的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#远程仓库的使用"}},[t._v("#")]),t._v(" 远程仓库的使用")]),t._v(" "),a("p",[t._v("管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。")]),t._v(" "),a("h2",{attrs:{id:"查看远程仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看远程仓库"}},[t._v("#")]),t._v(" 查看远程仓库")]),t._v(" "),a("p",[t._v("如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git clone https://github.com/schacon/ticgit\nCloning into 'ticgit'...\nremote: Reusing existing pack: 1857, done.\nremote: Total 1857 (delta 0), reused 0 (delta 0)\nReceiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.\nResolving deltas: 100% (772/772), done.\nChecking connectivity... done.\n$ cd ticgit\n$ git remote\norigin\n")])])]),a("p",[t._v("你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git remote -v\norigin\thttps://github.com/schacon/ticgit (fetch)\norigin\thttps://github.com/schacon/ticgit (push)\n")])])]),a("p",[t._v("如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ cd grit\n$ git remote -v\nbakkdoor  https://github.com/bakkdoor/grit (fetch)\nbakkdoor  https://github.com/bakkdoor/grit (push)\ncho45     https://github.com/cho45/grit (fetch)\ncho45     https://github.com/cho45/grit (push)\ndefunkt   https://github.com/defunkt/grit (fetch)\ndefunkt   https://github.com/defunkt/grit (push)\nkoke      git://github.com/koke/grit.git (fetch)\nkoke      git://github.com/koke/grit.git (push)\norigin    git@github.com:mojombo/grit.git (fetch)\norigin    git@github.com:mojombo/grit.git (push)\n")])])]),a("p",[t._v("这样我们可以轻松拉取其中任何一个用户的贡献。 此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。")]),t._v(" "),a("h2",{attrs:{id:"添加远程仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#添加远程仓库"}},[t._v("#")]),t._v(" 添加远程仓库")]),t._v(" "),a("p",[t._v("我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 "),a("code",[t._v("git remote add <shortname> <url>")]),t._v(" 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git remote\norigin\n$ git remote add pb https://github.com/paulboone/ticgit\n$ git remote -v\norigin\thttps://github.com/schacon/ticgit (fetch)\norigin\thttps://github.com/schacon/ticgit (push)\npb\thttps://github.com/paulboone/ticgit (fetch)\npb\thttps://github.com/paulboone/ticgit (push)\n")])])]),a("p",[t._v("现在你可以在命令行中使用字符串 "),a("code",[t._v("pb")]),t._v(" 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 "),a("code",[t._v("git fetch pb")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git fetch pb\nremote: Counting objects: 43, done.\nremote: Compressing objects: 100% (36/36), done.\nremote: Total 43 (delta 10), reused 31 (delta 5)\nUnpacking objects: 100% (43/43), done.\nFrom https://github.com/paulboone/ticgit\n * [new branch]      master     -> pb/master\n * [new branch]      ticgit     -> pb/ticgit\n")])])]),a("p",[t._v("现在 Paul 的 master 分支可以在本地通过 "),a("code",[t._v("pb/master")]),t._v(" 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。")]),t._v(" "),a("h2",{attrs:{id:"从远程仓库中抓取与拉取"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从远程仓库中抓取与拉取"}},[t._v("#")]),t._v(" 从远程仓库中抓取与拉取")]),t._v(" "),a("p",[t._v("从远程仓库中获得数据，可以执行：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git fetch [remote-name]\n")])])]),a("p",[t._v("这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。")]),t._v(" "),a("p",[t._v("如果你使用 "),a("code",[t._v("clone")]),t._v(" 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “"),a("code",[t._v("origin")]),t._v("” 为简写。 所以，"),a("code",[t._v("git fetch origin")]),t._v(" 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 "),a("code",[t._v("git fetch")]),t._v(" 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。")]),t._v(" "),a("p",[t._v("如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 Git 分支 了解更多信息），可以使用 "),a("code",[t._v("git pull")]),t._v(" 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，"),a("code",[t._v("git clone")]),t._v(" 命令会自动设置本地 "),a("code",[t._v("master")]),t._v(" 分支跟踪克隆的远程仓库的 "),a("code",[t._v("master")]),t._v(" 分支（或不管是什么名字的默认分支）。 运行 "),a("code",[t._v("git pull")]),t._v(" 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。")]),t._v(" "),a("h2",{attrs:{id:"推送到远程仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#推送到远程仓库"}},[t._v("#")]),t._v(" 推送到远程仓库")]),t._v(" "),a("p",[t._v("当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push [remote-name] [branch-name]。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git push origin master\n")])])]),a("p",[t._v("只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 Git 分支 了解如何推送到远程仓库服务器的详细信息。")]),t._v(" "),a("h2",{attrs:{id:"查看远程仓库-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看远程仓库-2"}},[t._v("#")]),t._v(" 查看远程仓库")]),t._v(" "),a("p",[t._v("如果想要查看某一个远程仓库的更多信息，可以使用 "),a("code",[t._v("git remote show [remote-name]")]),t._v(" 命令。 如果想以一个特定的缩写名运行这个命令，例如 "),a("code",[t._v("origin")]),t._v("，会得到像下面类似的信息：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git remote show origin\n* remote origin\n  Fetch URL: https://github.com/schacon/ticgit\n  Push  URL: https://github.com/schacon/ticgit\n  HEAD branch: master\n  Remote branches:\n    master                               tracked\n    dev-branch                           tracked\n  Local branch configured for 'git pull':\n    master merges with remote master\n  Local ref configured for 'git push':\n    master pushes to master (up to date)\n")])])]),a("h2",{attrs:{id:"远程仓库的移除与重命名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#远程仓库的移除与重命名"}},[t._v("#")]),t._v(" 远程仓库的移除与重命名")]),t._v(" "),a("p",[t._v("如果想要重命名引用的名字可以运行 "),a("code",[t._v("git remote rename")]),t._v(" 去修改一个远程仓库的简写名。 例如，想要将 "),a("code",[t._v("pb")]),t._v(" 重命名为 "),a("code",[t._v("paul")]),t._v("，可以用 "),a("code",[t._v("git remote rename")]),t._v(" 这样做：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git remote rename pb paul\n$ git remote\norigin\npaul\n")])])]),a("p",[t._v("值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 "),a("code",[t._v("pb/master")]),t._v(" 的现在会引用 "),a("code",[t._v("paul/master")]),t._v("。")]),t._v(" "),a("p",[t._v("如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 "),a("code",[t._v("git remote rm")]),t._v(" ：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ git remote rm paul\n$ git remote\norigin\n")])])]),a("h2",{attrs:{id:"打标签"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#打标签"}},[t._v("#")]),t._v(" 打标签")]),t._v(" "),a("p",[t._v("像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。")]),t._v(" "),a("h2",{attrs:{id:"git-别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-别名"}},[t._v("#")]),t._v(" Git 别名")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("现在，你可以完成所有基本的 Git 本地操作－创建或者克隆一个仓库、做更改、暂存并提交这些更改、浏览你的仓库从创建到现在的所有更改的历史。 下一步，本书将介绍 Git 的杀手级特性：分支模型。")])])}),[],!1,null,null,null);a.default=i.exports}}]);